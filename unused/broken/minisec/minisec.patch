diff -rcNP og/arch/arm/include/asm/elf.h patched/arch/arm/include/asm/elf.h
*** og/arch/arm/include/asm/elf.h	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/arm/include/asm/elf.h	2021-03-13 13:05:56.000000000 +0200
***************
*** 121,128 ****
  /* This is the base location for PIE (ET_DYN with INTERP) loads. */
  #define ELF_ET_DYN_BASE		0x400000UL
  
! /* When the program starts, a1 contains a pointer to a function to be 
!    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
     have no such handler.  */
  #define ELF_PLAT_INIT(_r, load_addr)	(_r)->ARM_r0 = 0
  
--- 121,135 ----
  /* This is the base location for PIE (ET_DYN with INTERP) loads. */
  #define ELF_ET_DYN_BASE		0x400000UL
  
! #ifdef CONFIG_MINISEC_ASLR
! #define PAX_ELF_ET_DYN_BASE	0x00008000UL
! 
! #define PAX_DELTA_MMAP_LEN	((current->personality == PER_LINUX_32BIT) ? 16 : 10)
! #define PAX_DELTA_STACK_LEN	((current->personality == PER_LINUX_32BIT) ? 16 : 10)
! #endif
! 
! /* When the program starts, a1 contains a pointer to a function to be
!    registered with atexit, as per the SVR4 ABI.  A value of 0 means we
     have no such handler.  */
  #define ELF_PLAT_INIT(_r, load_addr)	(_r)->ARM_r0 = 0
  
diff -rcNP og/arch/arm/mm/fault.c patched/arch/arm/mm/fault.c
*** og/arch/arm/mm/fault.c	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/arm/mm/fault.c	2021-03-13 13:08:57.000000000 +0200
***************
*** 157,162 ****
--- 157,169 ----
  				   tsk->comm, addr);
  #endif
  
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if ((tsk->mm->pax_flags & MF_PAX_PAGEEXEC) && (fsr & FSR_LNX_PF)) {
+ 		pax_report_fault(regs, (void *)regs->ARM_pc, (void *)regs->ARM_sp);
+ 		do_group_exit(SIGKILL);
+ 	}
+ #endif
+ 
  	tsk->thread.address = addr;
  	tsk->thread.error_code = fsr;
  	tsk->thread.trap_no = 14;
***************
*** 384,389 ****
--- 391,423 ----
  }
  #endif					/* CONFIG_MMU */
  
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+ {
+ 	long i;
+ 
+ 	printk(KERN_ERR "PAX: bytes at PC: ");
+ 	for (i = 0; i < 20; i++) {
+ 		unsigned char c;
+ 		if (get_user(c, (__force unsigned char __user *)pc+i))
+ 			printk(KERN_CONT "?? ");
+ 		else
+ 			printk(KERN_CONT "%02x ", c);
+ 	}
+ 	printk("\n");
+ 
+ 	printk(KERN_ERR "PAX: bytes at SP-4: ");
+ 	for (i = -1; i < 20; i++) {
+ 		unsigned long c;
+ 		if (get_user(c, (__force unsigned long __user *)sp+i))
+ 			printk(KERN_CONT "???????? ");
+ 		else
+ 			printk(KERN_CONT "%08lx ", c);
+ 	}
+ 	printk("\n");
+ }
+ #endif
+ 
  /*
   * First Level Translation Fault Handler
   *
diff -rcNP og/arch/x86/entry/entry_32.S patched/arch/x86/entry/entry_32.S
*** og/arch/x86/entry/entry_32.S	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/entry/entry_32.S	2021-03-13 13:11:14.000000000 +0200
***************
*** 360,365 ****
--- 360,374 ----
  .Lend_\@:
  .endm
  
+ .macro SAVE_ALL pt_regs_ax=%eax
+ #if defined(CONFIG_MINISEC_KERNEXEC) || defined(CONFIG_MINISEC_PAGEEXEC)
+ 	__SAVE_ALL \pt_regs_ax, __KERNEL_DS
+ 	pax_enter_kernel
+ #else
+ 	__SAVE_ALL \pt_regs_ax, __USER_DS
+ #endif
+ .endm
+ 
  .macro RESTORE_INT_REGS
  	popl	%ebx
  	popl	%ecx
***************
*** 1077,1084 ****
  	 */
  	TRACE_IRQS_OFF
  
- 	movl	%esp, %eax
- 	call	do_int80_syscall_32
  .Lsyscall_32_done:
  
  	STACKLEAK_ERASE
--- 1086,1091 ----
diff -rcNP og/arch/x86/entry/entry_64.S patched/arch/x86/entry/entry_64.S
*** og/arch/x86/entry/entry_64.S	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/entry/entry_64.S	2021-03-13 13:16:13.000000000 +0200
***************
*** 53,58 ****
--- 53,67 ----
  END(native_usergs_sysret64)
  #endif /* CONFIG_PARAVIRT */
  
+ #ifdef CONFIG_MINISEC_RANDKSTACK
+ .macro PAX_RAND_KSTACK
+ 	movq  %rsp, %rdi
+ 	call  pax_randomize_kstack
+ 	movq  %rsp, %rdi
+ 	movq  %rax, %rsp
+ .endm
+ #endif
+ 
  .macro TRACE_IRQS_FLAGS flags:req
  #ifdef CONFIG_TRACE_IRQFLAGS
  	btl	$9, \flags		/* interrupts off? */
***************
*** 170,178 ****
--- 179,205 ----
  	TRACE_IRQS_OFF
  
  	/* IRQs are off. */
+ 	/*
+ 	 * do_syscall_64 expects syscall-nr (pt_regs->orig_ax) as the first
+ 	 * argument (%rdi) and pointer to pt_regs as the second argument (%rsi).
+ 	 */
+ #ifdef CONFIG_MINISEC_RANDKSTACK
+ 	pushq	%rax
+ 	movq	%rsp, %rdi
+ 	call	pax_randomize_kstack
+ 	popq	%rdi
+ 	movq	%rsp, %rsi
+ 	movq	%rax, %rsp
+ 
+ 	pushq	%rsi
+ #else
  	movq	%rax, %rdi
  	movq	%rsp, %rsi
+ #endif
  	call	do_syscall_64		/* returns with IRQs disabled */
+ #ifdef CONFIG_MINISEC_RANDKSTACK
+ 	popq	%rsp
+ #endif
  
  	TRACE_IRQS_IRETQ		/* we're about to change IF */
  
***************
*** 340,348 ****
--- 367,383 ----
  
  2:
  	UNWIND_HINT_REGS
+ #ifdef CONFIG_MINISEC_RANDKSTACK
+   	PAX_RAND_KSTACK
+   	pushq	%rdi
+ #else
  	movq	%rsp, %rdi
+ #endif
  	call	syscall_return_slowpath	/* returns with IRQs disabled */
  	TRACE_IRQS_ON			/* user mode is traced as IRQS on */
+ #ifdef CONFIG_MINISEC_RANDKSTACK
+   	popq	%rsp
+ #endif
  	jmp	swapgs_restore_regs_and_return_to_usermode
  
  1:
diff -rcNP og/arch/x86/include/asm/elf.h patched/arch/x86/include/asm/elf.h
*** og/arch/x86/include/asm/elf.h	2021-03-13 19:47:09.000000000 +0200
--- patched/arch/x86/include/asm/elf.h	2021-03-13 13:18:43.000000000 +0200
***************
*** 254,259 ****
--- 254,273 ----
  #define ELF_ET_DYN_BASE		(mmap_is_ia32() ? 0x000400000UL : \
  						  0x100000000UL)
  
+ #ifdef CONFIG_MINISEC_ASLR
+ #ifdef CONFIG_X86_32
+ #define PAX_ELF_ET_DYN_BASE	0x10000000UL
+ 
+ #define PAX_DELTA_MMAP_LEN	(current->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+ #define PAX_DELTA_STACK_LEN	(current->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+ #else
+ #define PAX_ELF_ET_DYN_BASE	0x400000UL
+ 
+ #define PAX_DELTA_MMAP_LEN	((test_thread_flag(TIF_ADDR32)) ? 16 : CONFIG_TASK_SIZE_MAX_SHIFT - PAGE_SHIFT - 3)
+ #define PAX_DELTA_STACK_LEN	((test_thread_flag(TIF_ADDR32)) ? 16 : CONFIG_TASK_SIZE_MAX_SHIFT - PAGE_SHIFT - 3)
+ #endif
+ #endif
+ 
  /* This yields a mask that user programs can use to figure out what
     instruction set this CPU supports.  This could be done in user space,
     but it's not easy, and we've already done it here.  */
diff -rcNP og/arch/x86/include/asm/mmu.h patched/arch/x86/include/asm/mmu.h
*** og/arch/x86/include/asm/mmu.h	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/include/asm/mmu.h	2021-03-13 13:22:49.000000000 +0200
***************
*** 38,46 ****
  #endif
  
  	struct mutex lock;
! 	void __user *vdso;			/* vdso base address */
  	const struct vdso_image *vdso_image;	/* vdso image in use */
  
  	atomic_t perf_rdpmc_allowed;	/* nonzero if rdpmc is allowed */
  #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
  	/*
--- 38,58 ----
  #endif
  
  	struct mutex lock;
! 	unsigned long *vdso;			/* vdso base address */
  	const struct vdso_image *vdso_image;	/* vdso image in use */
  
+ #ifdef CONFIG_X86_32
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ 			unsigned long user_cs_base;
+ 			unsigned long user_cs_limit;
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(CONFIG_SMP)
+ 			cpumask_t cpu_user_cs_mask;
+ #endif
+ 
+ #endif
+ #endif
+ 
  	atomic_t perf_rdpmc_allowed;	/* nonzero if rdpmc is allowed */
  #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
  	/*
diff -rcNP og/arch/x86/include/asm/mmu_context.h patched/arch/x86/include/asm/mmu_context.h
*** og/arch/x86/include/asm/mmu_context.h	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/include/asm/mmu_context.h	2021-03-13 13:23:14.000000000 +0200
***************
*** 81,86 ****
--- 81,99 ----
  static inline void init_new_context_ldt(struct mm_struct *mm)
  {
  	mm->context.ldt = NULL;
+ 
+ #ifdef CONFIG_X86_32
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ 							mm->context.user_cs_base = 0UL;
+ 							mm->context.user_cs_limit = ~0UL;
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(CONFIG_SMP)
+ 							cpumask_clear(&mm->context.cpu_user_cs_mask);
+ #endif
+ 
+ #endif
+ #endif
+ 
  	init_rwsem(&mm->context.ldt_usr_sem);
  }
  int ldt_dup_context(struct mm_struct *oldmm, struct mm_struct *mm);
diff -rcNP og/arch/x86/kernel/cpu/common.c patched/arch/x86/kernel/cpu/common.c
*** og/arch/x86/kernel/cpu/common.c	2021-03-13 19:47:09.000000000 +0200
--- patched/arch/x86/kernel/cpu/common.c	2021-03-13 13:25:01.000000000 +0200
***************
*** 1524,1529 ****
--- 1524,1539 ----
  	setup_smap(c);
  	setup_umip(c);
  
+ #ifdef CONFIG_X86_32
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 			if (!(__supported_pte_mask & _PAGE_NX))
+ 							clear_cpu_cap(c, X86_FEATURE_PSE);
+ #endif
+ #ifdef CONFIG_MINISEC_KERNEXEC
+ 			clear_cpu_cap(c, X86_FEATURE_SEP);
+ #endif
+ #endif
+ 
  	/*
  	 * The vendor-specific functions might have changed features.
  	 * Now we do "generic changes."
diff -rcNP og/arch/x86/kernel/process_64.c patched/arch/x86/kernel/process_64.c
*** og/arch/x86/kernel/process_64.c	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/kernel/process_64.c	2021-03-13 13:26:21.000000000 +0200
***************
*** 63,68 ****
--- 63,83 ----
  
  #include "process.h"
  
+ #ifdef CONFIG_MINISEC_RANDKSTACK
+ unsigned long pax_randomize_kstack(struct pt_regs *regs)
+ {
+ 	unsigned long time;
+ 	unsigned long sp1;
+ 
+ 	if (!randomize_va_space)
+ 		return (unsigned long)regs;
+ 
+ 	time = rdtsc() & 0xFUL;
+ 	sp1 = (unsigned long)regs - (time << 4);
+ 	return sp1;
+ }
+ #endif
+ 
  /* Prints also some state that isn't saved in the pt_regs */
  void __show_regs(struct pt_regs *regs, enum show_regs_mode mode)
  {
diff -rcNP og/arch/x86/mm/fault.c patched/arch/x86/mm/fault.c
*** og/arch/x86/mm/fault.c	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/mm/fault.c	2021-03-13 13:37:22.000000000 +0200
***************
*** 142,147 ****
--- 142,155 ----
  	return prefetch;
  }
  
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ static bool pax_is_fetch_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address);
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ static int pax_handle_fetch_fault(struct pt_regs *regs);
+ #endif
+ 
  DEFINE_SPINLOCK(pgd_lock);
  LIST_HEAD(pgd_list);
  
***************
*** 420,426 ****
  
  #ifdef CONFIG_CPU_SUP_AMD
  static const char errata93_warning[] =
! KERN_ERR 
  "******* Your BIOS seems to not contain a fix for K8 errata #93\n"
  "******* Working around it, but it may cause SEGVs or burn power.\n"
  "******* Please consider a BIOS update.\n"
--- 428,434 ----
  
  #ifdef CONFIG_CPU_SUP_AMD
  static const char errata93_warning[] =
! KERN_ERR
  "******* Your BIOS seems to not contain a fix for K8 errata #93\n"
  "******* Working around it, but it may cause SEGVs or burn power.\n"
  "******* Please consider a BIOS update.\n"
***************
*** 907,912 ****
--- 915,935 ----
  		if (is_errata100(regs, address))
  			return;
  
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 		if (pax_is_fetch_fault(regs, error_code, address)) {
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 			switch (pax_handle_fetch_fault(regs)) {
+ 			case 2:
+ 				return;
+ 			}
+ #endif
+ 
+ 			pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+ 			do_group_exit(SIGKILL);
+ 		}
+ #endif
+ 
  		/*
  		 * To avoid leaking information about the kernel page table
  		 * layout, pretend that user-mode accesses to kernel addresses
***************
*** 1096,1101 ****
--- 1119,1226 ----
  	return 1;
  }
  
+ #if defined(CONFIG_X86_32) && defined(CONFIG_MINISEC_PAGEEXEC)
+ static inline unsigned long get_limit(unsigned long segment)
+ {
+ 	unsigned long __limit;
+ 
+ 	asm("lsll %1,%0" : "=r" (__limit) : "r" (segment));
+ 	return __limit + 1;
+ }
+ 
+ static int pax_handle_pageexec_fault(struct pt_regs *regs, struct mm_struct *mm, unsigned long address, unsigned long error_code)
+ {
+ 	pte_t *pte;
+ 	pmd_t *pmd;
+ 	spinlock_t *ptl;
+ 	unsigned char pte_mask;
+ 
+ 	if ((__supported_pte_mask & _PAGE_NX) || (error_code & (PF_PROT|PF_USER)) != (PF_PROT|PF_USER) || v8086_mode(regs) ||
+ 	    !(mm->pax_flags & MF_PAX_PAGEEXEC))
+ 		return 0;
+ 
+ 	/* PaX: it's our fault, let's handle it if we can */
+ 
+ 	/* PaX: take a look at read faults before acquiring any locks */
+ 	if (unlikely(!(error_code & PF_WRITE) && (regs->ip == address))) {
+ 		/* instruction fetch attempt from a protected page in user mode */
+ 		up_read(&mm->mmap_sem);
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 		switch (pax_handle_fetch_fault(regs)) {
+ 		case 2:
+ 			return 1;
+ 		}
+ #endif
+ 
+ 		pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+ 		do_group_exit(SIGKILL);
+ 	}
+ 
+ 	pmd = pax_get_pmd(mm, address);
+ 	if (unlikely(!pmd))
+ 		return 0;
+ 
+ 	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
+ 	if (unlikely(!(pte_val(*pte) & _PAGE_PRESENT) || pte_user(*pte))) {
+ 		pte_unmap_unlock(pte, ptl);
+ 		return 0;
+ 	}
+ 
+ 	if (unlikely((error_code & PF_WRITE) && !pte_write(*pte))) {
+ 		/* write attempt to a protected page in user mode */
+ 		pte_unmap_unlock(pte, ptl);
+ 		return 0;
+ 	}
+ 
+ #ifdef CONFIG_SMP
+ 	if (likely(address > get_limit(regs->cs) && cpumask_test_cpu(smp_processor_id(), &mm->context.cpu_user_cs_mask)))
+ #else
+ 	if (likely(address > get_limit(regs->cs)))
+ #endif
+ 	{
+ 		set_pte(pte, pte_mkread(*pte));
+ 		__flush_tlb_one(address);
+ 		pte_unmap_unlock(pte, ptl);
+ 		up_read(&mm->mmap_sem);
+ 		return 1;
+ 	}
+ 
+ 	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & PF_WRITE) << (_PAGE_BIT_DIRTY-1));
+ 
+ 	/*
+ 	 * PaX: fill DTLB with user rights and retry
+ 	 */
+ 	__asm__ __volatile__ (
+ 		"orb %2,(%1)\n"
+ #if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+ /*
+  * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+  * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+  * page fault when examined during a TLB load attempt. this is true not only
+  * for PTEs holding a non-present entry but also present entries that will
+  * raise a page fault (such as those set up by PaX, or the copy-on-write
+  * mechanism). in effect it means that we do *not* need to flush the TLBs
+  * for our target pages since their PTEs are simply not in the TLBs at all.
+  * the best thing in omitting it is that we gain around 15-20% speed in the
+  * fast path of the page fault handler and can get rid of tracing since we
+  * can no longer flush unintended entries.
+  */
+ 		"invlpg (%0)\n"
+ #endif
+ 		ASM_STAC "\n"
+ 		__copyuser_seg"testb $0,(%0)\n"
+ 		ASM_CLAC "\n"
+ 		"xorb %3,(%1)\n"
+ 		:
+ 		: "r" (address), "r" (pte), "q" (pte_mask), "i" (_PAGE_USER)
+ 		: "memory", "cc");
+ 	pte_unmap_unlock(pte, ptl);
+ 	up_read(&mm->mmap_sem);
+ 	return 1;
+ }
+ #endif
+ 
  /*
   * Handle a spurious fault caused by a stale TLB entry.
   *
***************
*** 1421,1426 ****
--- 1546,1556 ----
  		might_sleep();
  	}
  
+ #if defined(CONFIG_X86_32) && defined(CONFIG_MINISEC_PAGEEXEC)
+ 	if (pax_handle_pageexec_fault(regs, mm, address, error_code))
+ 		return;
+ #endif
+ 
  	vma = find_vma(mm, address);
  	if (unlikely(!vma)) {
  		bad_area(regs, hw_error_code, address);
***************
*** 1553,1555 ****
--- 1683,1941 ----
  	exception_exit(prev_state);
  }
  NOKPROBE_SYMBOL(do_page_fault);
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ static bool pax_is_fetch_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address)
+ {
+ 	struct mm_struct *mm = current->mm;
+ 	unsigned long ip = regs->ip;
+ 
+ 	if (v8086_mode(regs))
+ 		ip = ((regs->cs & 0xffff) << 4) + (ip & 0xffff);
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+ 		if ((__supported_pte_mask & _PAGE_NX) && (error_code & X86_PF_INSTR))
+ 			return true;
+ 		if (!(error_code & (X86_PF_PROT | X86_PF_WRITE)) && ip == address)
+ 			return true;
+ 		return false;
+ 	}
+ #endif
+ 
+ 	return false;
+ }
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ static int pax_handle_fetch_fault_32(struct pt_regs *regs)
+ {
+ 	int err;
+ 
+ 	do { /* PaX: libffi trampoline emulation */
+ 		unsigned char mov, jmp;
+ 		unsigned int addr1, addr2;
+ 
+ #ifdef CONFIG_X86_64
+ 		if ((regs->ip + 9) >> 32)
+ 			break;
+ #endif
+ 
+ 		err = get_user(mov, (unsigned char __user *)regs->ip);
+ 		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+ 		err |= get_user(jmp, (unsigned char __user *)(regs->ip + 5));
+ 		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+ 
+ 		if (err)
+ 			break;
+ 
+ 		if (mov == 0xB8 && jmp == 0xE9) {
+ 			regs->ax = addr1;
+ 			regs->ip = (unsigned int)(regs->ip + addr2 + 10);
+ 			return 2;
+ 		}
+ 	} while (0);
+ 
+ 	do { /* PaX: gcc trampoline emulation #1 */
+ 		unsigned char mov1, mov2;
+ 		unsigned short jmp;
+ 		unsigned int addr1, addr2;
+ 
+ #ifdef CONFIG_X86_64
+ 		if ((regs->ip + 11) >> 32)
+ 			break;
+ #endif
+ 
+ 		err = get_user(mov1, (unsigned char __user *)regs->ip);
+ 		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+ 		err |= get_user(mov2, (unsigned char __user *)(regs->ip + 5));
+ 		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+ 		err |= get_user(jmp, (unsigned short __user *)(regs->ip + 10));
+ 
+ 		if (err)
+ 			break;
+ 
+ 		if (mov1 == 0xB9 && mov2 == 0xB8 && jmp == 0xE0FF) {
+ 			regs->cx = addr1;
+ 			regs->ax = addr2;
+ 			regs->ip = addr2;
+ 			return 2;
+ 		}
+ 	} while (0);
+ 
+ 	do { /* PaX: gcc trampoline emulation #2 */
+ 		unsigned char mov, jmp;
+ 		unsigned int addr1, addr2;
+ 
+ #ifdef CONFIG_X86_64
+ 		if ((regs->ip + 9) >> 32)
+ 			break;
+ #endif
+ 
+ 		err = get_user(mov, (unsigned char __user *)regs->ip);
+ 		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+ 		err |= get_user(jmp, (unsigned char __user *)(regs->ip + 5));
+ 		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+ 
+ 		if (err)
+ 			break;
+ 
+ 		if (mov == 0xB9 && jmp == 0xE9) {
+ 			regs->cx = addr1;
+ 			regs->ip = (unsigned int)(regs->ip + addr2 + 10);
+ 			return 2;
+ 		}
+ 	} while (0);
+ 
+ 	return 1; /* PaX in action */
+ }
+ 
+ #ifdef CONFIG_X86_64
+ static int pax_handle_fetch_fault_64(struct pt_regs *regs)
+ {
+ 	int err;
+ 
+ 	do { /* PaX: libffi trampoline emulation */
+ 		unsigned short mov1, mov2, jmp1;
+ 		unsigned char stcclc, jmp2;
+ 		unsigned long addr1, addr2;
+ 
+ 		err = get_user(mov1, (unsigned short __user *)regs->ip);
+ 		err |= get_user(addr1, (unsigned long __user *)(regs->ip + 2));
+ 		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 10));
+ 		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 12));
+ 		err |= get_user(stcclc, (unsigned char __user *)(regs->ip + 20));
+ 		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 21));
+ 		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 23));
+ 
+ 		if (err)
+ 			break;
+ 
+ 		if (mov1 == 0xBB49 && mov2 == 0xBA49 && (stcclc == 0xF8 || stcclc == 0xF9) && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+ 			regs->r11 = addr1;
+ 			regs->r10 = addr2;
+ 			if (stcclc == 0xF8)
+ 				regs->flags &= ~X86_EFLAGS_CF;
+ 			else
+ 				regs->flags |= X86_EFLAGS_CF;
+ 			regs->ip = addr1;
+ 			return 2;
+ 		}
+ 	} while (0);
+ 
+ 	do { /* PaX: gcc trampoline emulation #1 */
+ 		unsigned short mov1, mov2, jmp1;
+ 		unsigned char jmp2;
+ 		unsigned int addr1;
+ 		unsigned long addr2;
+ 
+ 		err = get_user(mov1, (unsigned short __user *)regs->ip);
+ 		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 2));
+ 		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 6));
+ 		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 8));
+ 		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 16));
+ 		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 18));
+ 
+ 		if (err)
+ 			break;
+ 
+ 		if (mov1 == 0xBB41 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+ 			regs->r11 = addr1;
+ 			regs->r10 = addr2;
+ 			regs->ip = addr1;
+ 			return 2;
+ 		}
+ 	} while (0);
+ 
+ 	do { /* PaX: gcc trampoline emulation #2 */
+ 		unsigned short mov1, mov2, jmp1;
+ 		unsigned char jmp2;
+ 		unsigned long addr1, addr2;
+ 
+ 		err = get_user(mov1, (unsigned short __user *)regs->ip);
+ 		err |= get_user(addr1, (unsigned long __user *)(regs->ip + 2));
+ 		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 10));
+ 		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 12));
+ 		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 20));
+ 		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 22));
+ 
+ 		if (err)
+ 			break;
+ 
+ 		if (mov1 == 0xBB49 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+ 			regs->r11 = addr1;
+ 			regs->r10 = addr2;
+ 			regs->ip = addr1;
+ 			return 2;
+ 		}
+ 	} while (0);
+ 
+ 	return 1; /* PaX in action */
+ }
+ #endif
+ 
+ /*
+  * PaX: decide what to do with offenders (regs->ip = fault address)
+  *
+  * returns 1 when task should be killed
+  *         2 when gcc trampoline was detected
+  */
+ static int pax_handle_fetch_fault(struct pt_regs *regs)
+ {
+ 	if (v8086_mode(regs))
+ 		return 1;
+ 
+ 	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+ 		return 1;
+ 
+ #ifdef CONFIG_X86_32
+ 	return pax_handle_fetch_fault_32(regs);
+ #else
+ 	if (regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT))
+ 		return pax_handle_fetch_fault_32(regs);
+ 	else
+ 		return pax_handle_fetch_fault_64(regs);
+ #endif
+ }
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+ {
+ 	long i;
+ 
+ 	printk(KERN_ERR "PAX: bytes at PC: ");
+ 	for (i = 0; i < 20; i++) {
+ 		unsigned char c;
+ 		if (get_user(c, (unsigned char *)pc+i))
+ 			printk(KERN_CONT "?? ");
+ 		else
+ 			printk(KERN_CONT "%02x ", c);
+ 	}
+ 	printk("\n");
+ 
+ 	printk(KERN_ERR "PAX: bytes at SP-%lu: ", (unsigned long)sizeof(long));
+ 	for (i = -1; i < 80 / (long)sizeof(long); i++) {
+ 		unsigned long c;
+ 		if (get_user(c, (unsigned long *)sp+i)) {
+ #ifdef CONFIG_X86_32
+ 			printk(KERN_CONT "???????? ");
+ #else
+ 			if ((regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT)))
+ 				printk(KERN_CONT "???????? ???????? ");
+ 			else
+ 				printk(KERN_CONT "???????????????? ");
+ #endif
+ 		} else {
+ #ifdef CONFIG_X86_64
+ 			if ((regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT))) {
+ 				printk(KERN_CONT "%08x ", (unsigned int)c);
+ 				printk(KERN_CONT "%08x ", (unsigned int)(c >> 32));
+ 			} else
+ #endif
+ 				printk(KERN_CONT "%0*lx ", 2 * (int)sizeof(long), c);
+ 		}
+ 	}
+ 	printk("\n");
+ }
+ #endif
diff -rcNP og/arch/x86/mm/setup_nx.c patched/arch/x86/mm/setup_nx.c
*** og/arch/x86/mm/setup_nx.c	2021-03-11 15:06:51.000000000 +0200
--- patched/arch/x86/mm/setup_nx.c	2021-03-13 13:39:24.000000000 +0200
***************
*** 7,14 ****
--- 7,16 ----
  #include <asm/proto.h>
  #include <asm/cpufeature.h>
  
+ #if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
  static int disable_nx;
  
+ #ifndef CONFIG_MINISEC_PAGEEXEC
  /*
   * noexec = on|off
   *
***************
*** 30,35 ****
--- 32,40 ----
  	return 0;
  }
  early_param("noexec", noexec_setup);
+ #endif
+ 
+ #endif
  
  void x86_configure_nx(void)
  {
diff -rcNP og/drivers/pci/proc.c patched/drivers/pci/proc.c
*** og/drivers/pci/proc.c	2021-03-11 15:06:51.000000000 +0200
--- patched/drivers/pci/proc.c	2021-03-13 13:43:13.000000000 +0200
***************
*** 449,455 ****
--- 449,463 ----
  static int __init pci_proc_init(void)
  {
  	struct pci_dev *dev = NULL;
+ #ifdef CONFIG_MINISEC_PROC_ADD
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	proc_bus_pci_dir = proc_mkdir_mode("bus/pci", S_IRUSR | S_IXUSR, NULL);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	proc_bus_pci_dir = proc_mkdir_mode("bus/pci", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+ #endif
+ #else
  	proc_bus_pci_dir = proc_mkdir("bus/pci", NULL);
+ #endif
  	proc_create_seq("devices", 0, proc_bus_pci_dir,
  		    &proc_bus_pci_devices_op);
  	proc_initialized = 1;
diff -rcNP og/drivers/tty/tty_io.c patched/drivers/tty/tty_io.c
*** og/drivers/tty/tty_io.c	2021-03-13 19:47:09.000000000 +0200
--- patched/drivers/tty/tty_io.c	2021-03-13 13:48:21.000000000 +0200
***************
*** 108,113 ****
--- 108,115 ----
  #include <linux/kmod.h>
  #include <linux/nsproxy.h>
  
+ #include <linux/minisec.h>
+ 
  #undef TTY_DEBUG_HANGUP
  #ifdef TTY_DEBUG_HANGUP
  # define tty_debug_hangup(tty, f, args...)	tty_debug(tty, f, ##args)
***************
*** 2194,2199 ****
--- 2196,2203 ----
  			"Denied TIOCSTI ioctl for non-privileged process\n");
  		return -EPERM;
  	}
+ 	if (gr_handle_tiocsti(tty))
+ 		return -EPERM;
  	if ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))
  		return -EPERM;
  	if (get_user(ch, p))
***************
*** 2875,2881 ****
  		return 0;
  	return file_tty(file) != t ? 0 : fd + 1;
  }
! 	
  /*
   * This implements the "Secure Attention Key" ---  the idea is to
   * prevent trojan horses by killing all processes associated with this
--- 2879,2885 ----
  		return 0;
  	return file_tty(file) != t ? 0 : fd + 1;
  }
! 
  /*
   * This implements the "Secure Attention Key" ---  the idea is to
   * prevent trojan horses by killing all processes associated with this
***************
*** 3520,3523 ****
  #endif
  	return 0;
  }
- 
--- 3524,3526 ----
diff -rcNP og/drivers/tty/vt/keyboard.c patched/drivers/tty/vt/keyboard.c
*** og/drivers/tty/vt/keyboard.c	2021-03-11 15:06:51.000000000 +0200
--- patched/drivers/tty/vt/keyboard.c	2021-03-13 13:52:21.000000000 +0200
***************
*** 637,642 ****
--- 637,650 ----
  	     kbd->kbdmode == VC_OFF) &&
  	     value != KVAL(K_SAK))
  		return;		/* SAK is allowed even in raw mode */
+ #if defined(CONFIG_MINISEC_PROC) || defined(CONFIG_MINISEC_PROC_MEMMAP)
+ 	{
+ 		void *func = fn_handler[value];
+ 		if (func == fn_show_state || func == fn_show_ptregs ||
+ 		    func == fn_show_mem)
+ 			return;
+ 	}
+ #endif
  	fn_handler[value](vc);
  }
  
***************
*** 1780,1786 ****
  					  ct * sizeof(struct kbdiacruc));
  			if (IS_ERR(buf))
  				return PTR_ERR(buf);
! 		} 
  		spin_lock_irqsave(&kbd_event_lock, flags);
  		if (ct)
  			memcpy(accent_table, buf,
--- 1788,1794 ----
  					  ct * sizeof(struct kbdiacruc));
  			if (IS_ERR(buf))
  				return PTR_ERR(buf);
! 		}
  		spin_lock_irqsave(&kbd_event_lock, flags);
  		if (ct)
  			memcpy(accent_table, buf,
***************
*** 1918,1923 ****
--- 1926,1933 ----
  		spin_unlock_irqrestore(&kbd_event_lock, flags);
  		return put_user(val, &user_kbe->kb_value);
  	case KDSKBENT:
+ 		if (!capable(CAP_SYS_TTY_CONFIG))
+ 			perm = 0;
  		if (!perm)
  			return -EPERM;
  		if (!i && v == K_NOSUCHMAP) {
diff -rcNP og/fs/binfmt_elf.c patched/fs/binfmt_elf.c
*** og/fs/binfmt_elf.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/binfmt_elf.c	2021-03-13 14:01:45.000000000 +0200
***************
*** 42,47 ****
--- 42,48 ----
  #include <linux/cred.h>
  #include <linux/dax.h>
  #include <linux/uaccess.h>
+ #include <linux/xattr.h>
  #include <asm/param.h>
  #include <asm/page.h>
  
***************
*** 75,80 ****
--- 76,85 ----
  #define elf_core_dump	NULL
  #endif
  
+ #ifdef CONFIG_MINISEC_MPROTECT
+ static void elf_handle_mprotect(struct vm_area_struct *vma, unsigned long newflags);
+ #endif
+ 
  #if ELF_EXEC_PAGESIZE > PAGE_SIZE
  #define ELF_MIN_ALIGN	ELF_EXEC_PAGESIZE
  #else
***************
*** 94,99 ****
--- 99,107 ----
  	.load_binary	= load_elf_binary,
  	.load_shlib	= load_elf_library,
  	.core_dump	= elf_core_dump,
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	.handle_mprotect= elf_handle_mprotect,
+ #endif
  	.min_coredump	= ELF_EXEC_PAGESIZE,
  };
  
***************
*** 235,241 ****
  	} while (0)
  
  #ifdef ARCH_DLINFO
! 	/* 
  	 * ARCH_DLINFO must come first so PPC can do its special alignment of
  	 * AUXV.
  	 * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in
--- 243,249 ----
  	} while (0)
  
  #ifdef ARCH_DLINFO
! 	/*
  	 * ARCH_DLINFO must come first so PPC can do its special alignment of
  	 * AUXV.
  	 * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in
***************
*** 665,670 ****
--- 673,1008 ----
  	return error;
  }
  
+ #ifdef CONFIG_MINISEC_PT_PAX_FLAGS
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ static unsigned long pax_parse_pt_pax_softmode(const struct elf_phdr * const elf_phdata)
+ {
+ 	unsigned long pax_flags = 0UL;
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (elf_phdata->p_flags & PF_PAGEEXEC)
+ 		pax_flags |= MF_PAX_PAGEEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SEGMEXEC
+ 	if (elf_phdata->p_flags & PF_SEGMEXEC)
+ 		pax_flags |= MF_PAX_SEGMEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 	if ((elf_phdata->p_flags & PF_EMUTRAMP) && (pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)))
+ 		pax_flags |= MF_PAX_EMUTRAMP;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (elf_phdata->p_flags & PF_MPROTECT)
+ 		pax_flags |= MF_PAX_MPROTECT;
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_RANDMMAP) || defined(CONFIG_MINISEC_RANDUSTACK)
+ 	if (randomize_va_space && (elf_phdata->p_flags & PF_RANDMMAP))
+ 		pax_flags |= MF_PAX_RANDMMAP;
+ #endif
+ 
+ 	return pax_flags;
+ }
+ #endif
+ 
+ static unsigned long pax_parse_pt_pax_hardmode(const struct elf_phdr * const elf_phdata)
+ {
+ 	unsigned long pax_flags = 0UL;
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (!(elf_phdata->p_flags & PF_NOPAGEEXEC))
+ 		pax_flags |= MF_PAX_PAGEEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SEGMEXEC
+ 	if (!(elf_phdata->p_flags & PF_NOSEGMEXEC))
+ 		pax_flags |= MF_PAX_SEGMEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 	if (!(elf_phdata->p_flags & PF_NOEMUTRAMP))
+ 		pax_flags |= MF_PAX_EMUTRAMP;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (!(elf_phdata->p_flags & PF_NOMPROTECT))
+ 		pax_flags |= MF_PAX_MPROTECT;
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_RANDMMAP) || defined(CONFIG_MINISEC_RANDUSTACK)
+ 	if (randomize_va_space && !(elf_phdata->p_flags & PF_NORANDMMAP))
+ 		pax_flags |= MF_PAX_RANDMMAP;
+ #endif
+ 
+ 	return pax_flags;
+ }
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ static unsigned long pax_parse_xattr_pax_softmode(unsigned long pax_flags_softmode)
+ {
+ 	unsigned long pax_flags = 0UL;
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (pax_flags_softmode & MF_PAX_PAGEEXEC)
+ 		pax_flags |= MF_PAX_PAGEEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SEGMEXEC
+ 	if (pax_flags_softmode & MF_PAX_SEGMEXEC)
+ 		pax_flags |= MF_PAX_SEGMEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 	if ((pax_flags_softmode & MF_PAX_EMUTRAMP) && (pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)))
+ 		pax_flags |= MF_PAX_EMUTRAMP;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (pax_flags_softmode & MF_PAX_MPROTECT)
+ 		pax_flags |= MF_PAX_MPROTECT;
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_RANDMMAP) || defined(CONFIG_MINISEC_RANDUSTACK)
+ 	if (randomize_va_space && (pax_flags_softmode & MF_PAX_RANDMMAP))
+ 		pax_flags |= MF_PAX_RANDMMAP;
+ #endif
+ 
+ 	return pax_flags;
+ }
+ #endif
+ 
+ static unsigned long pax_parse_xattr_pax_hardmode(unsigned long pax_flags_hardmode)
+ {
+ 	unsigned long pax_flags = 0UL;
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (!(pax_flags_hardmode & MF_PAX_PAGEEXEC))
+ 		pax_flags |= MF_PAX_PAGEEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SEGMEXEC
+ 	if (!(pax_flags_hardmode & MF_PAX_SEGMEXEC))
+ 		pax_flags |= MF_PAX_SEGMEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 	if (!(pax_flags_hardmode & MF_PAX_EMUTRAMP))
+ 		pax_flags |= MF_PAX_EMUTRAMP;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (!(pax_flags_hardmode & MF_PAX_MPROTECT))
+ 		pax_flags |= MF_PAX_MPROTECT;
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_RANDMMAP) || defined(CONFIG_MINISEC_RANDUSTACK)
+ 	if (randomize_va_space && !(pax_flags_hardmode & MF_PAX_RANDMMAP))
+ 		pax_flags |= MF_PAX_RANDMMAP;
+ #endif
+ 
+ 	return pax_flags;
+ }
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_NOEXEC) || defined(CONFIG_MINISEC_ASLR)
+ static unsigned long pax_parse_defaults(void)
+ {
+ 	unsigned long pax_flags = 0UL;
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ 	if (pax_softmode)
+ 		return pax_flags;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	pax_flags |= MF_PAX_PAGEEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SEGMEXEC
+ 	pax_flags |= MF_PAX_SEGMEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	pax_flags |= MF_PAX_MPROTECT;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_RANDMMAP
+ 	if (randomize_va_space)
+ 		pax_flags |= MF_PAX_RANDMMAP;
+ #endif
+ 
+ 	return pax_flags;
+ }
+ 
+ static unsigned long pax_parse_ei_pax(const struct elfhdr * const elf_ex)
+ {
+ 	unsigned long pax_flags = PAX_PARSE_FLAGS_FALLBACK;
+ 
+ #ifdef CONFIG_MINISEC_EI_PAX
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ 	if (pax_softmode)
+ 		return pax_flags;
+ #endif
+ 
+ 	pax_flags = 0UL;
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_PAGEEXEC))
+ 		pax_flags |= MF_PAX_PAGEEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SEGMEXEC
+ 	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_SEGMEXEC))
+ 		pax_flags |= MF_PAX_SEGMEXEC;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && (elf_ex->e_ident[EI_PAX] & EF_PAX_EMUTRAMP))
+ 		pax_flags |= MF_PAX_EMUTRAMP;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && !(elf_ex->e_ident[EI_PAX] & EF_PAX_MPROTECT))
+ 		pax_flags |= MF_PAX_MPROTECT;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_ASLR
+ 	if (randomize_va_space && !(elf_ex->e_ident[EI_PAX] & EF_PAX_RANDMMAP))
+ 		pax_flags |= MF_PAX_RANDMMAP;
+ #endif
+ 
+ #endif
+ 
+ 	return pax_flags;
+ 
+ }
+ 
+ static unsigned long pax_parse_pt_pax(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata)
+ {
+ 
+ #ifdef CONFIG_MINISEC_PT_PAX_FLAGS
+ 	unsigned long i;
+ 
+ 	for (i = 0UL; i < elf_ex->e_phnum; i++)
+ 		if (elf_phdata[i].p_type == PT_PAX_FLAGS) {
+ 			if (((elf_phdata[i].p_flags & PF_PAGEEXEC) && (elf_phdata[i].p_flags & PF_NOPAGEEXEC)) ||
+ 			    ((elf_phdata[i].p_flags & PF_SEGMEXEC) && (elf_phdata[i].p_flags & PF_NOSEGMEXEC)) ||
+ 			    ((elf_phdata[i].p_flags & PF_EMUTRAMP) && (elf_phdata[i].p_flags & PF_NOEMUTRAMP)) ||
+ 			    ((elf_phdata[i].p_flags & PF_MPROTECT) && (elf_phdata[i].p_flags & PF_NOMPROTECT)) ||
+ 			    ((elf_phdata[i].p_flags & PF_RANDMMAP) && (elf_phdata[i].p_flags & PF_NORANDMMAP)))
+ 				return PAX_PARSE_FLAGS_FALLBACK;
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ 			if (pax_softmode)
+ 				return pax_parse_pt_pax_softmode(&elf_phdata[i]);
+ 			else
+ #endif
+ 
+ 				return pax_parse_pt_pax_hardmode(&elf_phdata[i]);
+ 			break;
+ 		}
+ #endif
+ 
+ 	return PAX_PARSE_FLAGS_FALLBACK;
+ }
+ 
+ static unsigned long pax_parse_xattr_pax(struct file * const file)
+ {
+ 
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ 	ssize_t xattr_size, i;
+ 	unsigned char xattr_value[sizeof("pemrs") - 1];
+ 	unsigned long pax_flags_hardmode = 0UL, pax_flags_softmode = 0UL;
+ 
+ 	xattr_size = pax_getxattr(file->f_path.dentry, xattr_value, sizeof xattr_value);
+ 	if (xattr_size < 0 || xattr_size > sizeof xattr_value)
+ 		return PAX_PARSE_FLAGS_FALLBACK;
+ 
+ 	for (i = 0; i < xattr_size; i++)
+ 		switch (xattr_value[i]) {
+ 		default:
+ 			return PAX_PARSE_FLAGS_FALLBACK;
+ 
+ #define parse_flag(option1, option2, flag)			\
+ 		case option1:					\
+ 			if (pax_flags_hardmode & MF_PAX_##flag)	\
+ 				return PAX_PARSE_FLAGS_FALLBACK;\
+ 			pax_flags_hardmode |= MF_PAX_##flag;	\
+ 			break;					\
+ 		case option2:					\
+ 			if (pax_flags_softmode & MF_PAX_##flag)	\
+ 				return PAX_PARSE_FLAGS_FALLBACK;\
+ 			pax_flags_softmode |= MF_PAX_##flag;	\
+ 			break;
+ 
+ 		parse_flag('p', 'P', PAGEEXEC);
+ 		parse_flag('e', 'E', EMUTRAMP);
+ 		parse_flag('m', 'M', MPROTECT);
+ 		parse_flag('r', 'R', RANDMMAP);
+ 		parse_flag('s', 'S', SEGMEXEC);
+ 
+ #undef parse_flag
+ 		}
+ 
+ 	if (pax_flags_hardmode & pax_flags_softmode)
+ 		return PAX_PARSE_FLAGS_FALLBACK;
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ 	if (pax_softmode)
+ 		return pax_parse_xattr_pax_softmode(pax_flags_softmode);
+ 	else
+ #endif
+ 
+ 		return pax_parse_xattr_pax_hardmode(pax_flags_hardmode);
+ #else
+ 	return PAX_PARSE_FLAGS_FALLBACK;
+ #endif
+ 
+ }
+ 
+ static long pax_parse_pax_flags(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata, struct file * const file)
+ {
+ 	unsigned long pax_flags, ei_pax_flags,  pt_pax_flags, xattr_pax_flags;
+ 
+ 	pax_flags = pax_parse_defaults();
+ 	ei_pax_flags = pax_parse_ei_pax(elf_ex);
+ 	pt_pax_flags = pax_parse_pt_pax(elf_ex, elf_phdata);
+ 	xattr_pax_flags = pax_parse_xattr_pax(file);
+ 
+ 	if (pt_pax_flags != PAX_PARSE_FLAGS_FALLBACK &&
+ 	    xattr_pax_flags != PAX_PARSE_FLAGS_FALLBACK &&
+ 	    pt_pax_flags != xattr_pax_flags)
+ 		return -EINVAL;
+ 	if (xattr_pax_flags != PAX_PARSE_FLAGS_FALLBACK)
+ 		pax_flags = xattr_pax_flags;
+ 	else if (pt_pax_flags != PAX_PARSE_FLAGS_FALLBACK)
+ 		pax_flags = pt_pax_flags;
+ 	else if (ei_pax_flags != PAX_PARSE_FLAGS_FALLBACK)
+ 		pax_flags = ei_pax_flags;
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(CONFIG_MINISEC_SEGMEXEC)
+ 	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) == (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+ 		if ((__supported_pte_mask & _PAGE_NX))
+ 			pax_flags &= ~MF_PAX_SEGMEXEC;
+ 		else
+ 			pax_flags &= ~MF_PAX_PAGEEXEC;
+ 	}
+ #endif
+ 
+ 	if (0 > pax_check_flags(&pax_flags))
+ 		return -EINVAL;
+ 
+ 	current->mm->pax_flags = pax_flags;
+ 	return 0;
+ }
+ #endif
+ 
  /*
   * These are the functions used to load ELF style executables and shared
   * libraries.  There is no binary dependent code anywhere else.
***************
*** 697,703 ****
  		retval = -ENOMEM;
  		goto out_ret;
  	}
! 	
  	/* Get the exec-header */
  	loc->elf_ex = *((struct elfhdr *)bprm->buf);
  
--- 1035,1041 ----
  		retval = -ENOMEM;
  		goto out_ret;
  	}
! 
  	/* Get the exec-header */
  	loc->elf_ex = *((struct elfhdr *)bprm->buf);
  
***************
*** 851,856 ****
--- 1189,1232 ----
  	/* Do this immediately, since STACK_TOP as used in setup_arg_pages
  	   may depend on the personality.  */
  	SET_PERSONALITY2(loc->elf_ex, &arch_state);
+ 
+ #if defined(CONFIG_MINISEC_NOEXEC) || defined(CONFIG_MINISEC_ASLR)
+ 	current->mm->pax_flags = 0UL;
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(X86_32)
+ 	if ((current->mm->pax_flags & MF_PAX_PAGEEXEC) && !(__supported_pte_mask & _PAGE_NX)) {
+ 		current->mm->context.user_cs_limit = PAGE_SIZE;
+ 		current->mm->def_flags |= VM_PAGEEXEC | VM_NOHUGEPAGE;
+ 	}
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_ASLR
+ 	current->mm->delta_mmap = 0UL;
+ 	current->mm->delta_stack = 0UL;
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_NOEXEC) || defined(CONFIG_MINISEC_ASLR)
+ 	if (0 > pax_parse_pax_flags(elf_ex, elf_phdata, bprm->file)) {
+ 		retval = -EINVAL;
+ 		goto out_free_dentry;
+ 	}
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_ASLR
+ 	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+ 		current->mm->delta_mmap = (pax_get_random_long() & ((1UL << PAX_DELTA_MMAP_LEN)-1)) << PAGE_SHIFT;
+ 		current->mm->delta_stack = (pax_get_random_long() & ((1UL << PAX_DELTA_STACK_LEN)-1)) << PAGE_SHIFT;
+ 	}
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	if (current->mm->pax_flags & MF_PAX_PAGEEXEC) {
+ 		executable_stack = EXSTACK_DISABLE_X;
+ 		current->personality &= ~READ_IMPLIES_EXEC;
+ 	} else
+ #endif
+ 
  	if (elf_read_implies_exec(loc->elf_ex, executable_stack))
  		current->personality |= READ_IMPLIES_EXEC;
  
***************
*** 866,872 ****
  				 executable_stack);
  	if (retval < 0)
  		goto out_free_dentry;
! 	
  	elf_bss = 0;
  	elf_brk = 0;
  
--- 1242,1248 ----
  				 executable_stack);
  	if (retval < 0)
  		goto out_free_dentry;
! 
  	elf_bss = 0;
  	elf_brk = 0;
  
***************
*** 888,894 ****
  
  		if (unlikely (elf_brk > elf_bss)) {
  			unsigned long nbyte;
! 	            
  			/* There was a PT_LOAD segment with p_memsz > p_filesz
  			   before this one. Map anonymous pages, if needed,
  			   and clear the area.  */
--- 1264,1270 ----
  
  		if (unlikely (elf_brk > elf_bss)) {
  			unsigned long nbyte;
! 
  			/* There was a PT_LOAD segment with p_memsz > p_filesz
  			   before this one. Map anonymous pages, if needed,
  			   and clear the area.  */
***************
*** 1456,1462 ****
  	phdr->p_align = 0;
  }
  
! static void fill_note(struct memelfnote *note, const char *name, int type, 
  		unsigned int sz, void *data)
  {
  	note->name = name;
--- 1832,1838 ----
  	phdr->p_align = 0;
  }
  
! static void fill_note(struct memelfnote *note, const char *name, int type,
  		unsigned int sz, void *data)
  {
  	note->name = name;
***************
*** 1508,1514 ****
  {
  	const struct cred *cred;
  	unsigned int i, len;
! 	
  	/* first copy the parameters from user space */
  	memset(psinfo, 0, sizeof(struct elf_prpsinfo));
  
--- 1884,1890 ----
  {
  	const struct cred *cred;
  	unsigned int i, len;
! 
  	/* first copy the parameters from user space */
  	memset(psinfo, 0, sizeof(struct elf_prpsinfo));
  
***************
*** 1542,1548 ****
  	SET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));
  	rcu_read_unlock();
  	strncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));
! 	
  	return 0;
  }
  
--- 1918,1924 ----
  	SET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));
  	rcu_read_unlock();
  	strncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));
! 
  	return 0;
  }
  
***************
*** 1939,1946 ****
  	t->num_notes = 0;
  
  	fill_prstatus(&t->prstatus, p, signr);
! 	elf_core_copy_task_regs(p, &t->prstatus.pr_reg);	
! 	
  	fill_note(&t->notes[0], "CORE", NT_PRSTATUS, sizeof(t->prstatus),
  		  &(t->prstatus));
  	t->num_notes++;
--- 2315,2322 ----
  	t->num_notes = 0;
  
  	fill_prstatus(&t->prstatus, p, signr);
! 	elf_core_copy_task_regs(p, &t->prstatus.pr_reg);
! 
  	fill_note(&t->notes[0], "CORE", NT_PRSTATUS, sizeof(t->prstatus),
  		  &(t->prstatus));
  	t->num_notes++;
***************
*** 1961,1967 ****
  		t->num_notes++;
  		sz += notesize(&t->notes[2]);
  	}
! #endif	
  	return sz;
  }
  
--- 2337,2343 ----
  		t->num_notes++;
  		sz += notesize(&t->notes[2]);
  	}
! #endif
  	return sz;
  }
  
***************
*** 2199,2205 ****
  
  	/*
  	 * We no longer stop all VM operations.
! 	 * 
  	 * This is because those proceses that could possibly change map_count
  	 * or the mmap / vma pages are now blocked in do_exit on current
  	 * finishing this core dump.
--- 2575,2581 ----
  
  	/*
  	 * We no longer stop all VM operations.
! 	 *
  	 * This is because those proceses that could possibly change map_count
  	 * or the mmap / vma pages are now blocked in do_exit on current
  	 * finishing this core dump.
***************
*** 2208,2214 ****
  	 * the map_count or the pages allocated. So no possibility of crashing
  	 * exists while dumping the mm->vm_next areas to the core file.
  	 */
!   
  	/* alloc memory for large data structures: too large to be on stack */
  	elf = kmalloc(sizeof(*elf), GFP_KERNEL);
  	if (!elf)
--- 2584,2590 ----
  	 * the map_count or the pages allocated. So no possibility of crashing
  	 * exists while dumping the mm->vm_next areas to the core file.
  	 */
! 
  	/* alloc memory for large data structures: too large to be on stack */
  	elf = kmalloc(sizeof(*elf), GFP_KERNEL);
  	if (!elf)
***************
*** 2383,2388 ****
--- 2759,2880 ----
  
  #endif		/* CONFIG_ELF_CORE */
  
+ #ifdef CONFIG_MINISEC_MPROTECT
+ /* PaX: non-PIC ELF libraries need relocations on their executable segments
+  * therefore we'll grant them VM_MAYWRITE once during their life. Similarly
+  * we'll remove VM_MAYWRITE for good on RELRO segments.
+  *
+  * The checks favour ld-linux.so behaviour which operates on a per ELF segment
+  * basis because we want to allow the common case and not the special ones.
+  */
+ static void elf_handle_mprotect(struct vm_area_struct *vma, unsigned long newflags)
+ {
+ 	struct elfhdr elf_h;
+ 	struct elf_phdr elf_p;
+ 	unsigned long i;
+ 	unsigned long oldflags;
+ 	bool is_textrel_rw, is_textrel_rx, is_relro;
+ 
+ 	if (!(vma->vm_mm->pax_flags & MF_PAX_MPROTECT) || !vma->vm_file)
+ 		return;
+ 
+ 	oldflags = vma->vm_flags & (VM_MAYEXEC | VM_MAYWRITE | VM_MAYREAD | VM_EXEC | VM_WRITE | VM_READ);
+ 	newflags &= VM_MAYEXEC | VM_MAYWRITE | VM_MAYREAD | VM_EXEC | VM_WRITE | VM_READ;
+ 
+ 	/* possible RELRO */
+ 	is_relro = vma->anon_vma && oldflags == (VM_MAYWRITE | VM_MAYREAD | VM_READ) && newflags == (VM_MAYWRITE | VM_MAYREAD | VM_READ);
+ 
+ 	if (!is_textrel_rw && !is_textrel_rx && !is_relro)
+ 		return;
+ 
+ 	if (sizeof(elf_h) != kernel_read(vma->vm_file, 0UL, (char *)&elf_h, sizeof(elf_h)) ||
+ 	    memcmp(elf_h.e_ident, ELFMAG, SELFMAG) ||
+ 
+ 	    (is_relro && (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC)) ||
+ 	    !elf_check_arch(&elf_h) ||
+ 	    elf_h.e_phentsize != sizeof(struct elf_phdr) ||
+ 	    elf_h.e_phnum > 65536UL / sizeof(struct elf_phdr))
+ 		return;
+ 
+ 	for (i = 0UL; i < elf_h.e_phnum; i++) {
+ 		if (sizeof(elf_p) != kernel_read(vma->vm_file, elf_h.e_phoff + i*sizeof(elf_p), (char *)&elf_p, sizeof(elf_p)))
+ 			return;
+ 		switch (elf_p.p_type) {
+ 		case PT_DYNAMIC:
+ 			if (!is_textrel_rw && !is_textrel_rx)
+ 				continue;
+ 			i = 0UL;
+ 			while ((i+1) * sizeof(elf_dyn) <= elf_p.p_filesz) {
+ 				elf_dyn dyn;
+ 
+ 				if (sizeof(dyn) != kernel_read(vma->vm_file, elf_p.p_offset + i*sizeof(dyn), (char *)&dyn, sizeof(dyn)))
+ 					break;
+ 				if (dyn.d_tag == DT_NULL)
+ 					break;
+ 				if (dyn.d_tag == DT_TEXTREL || (dyn.d_tag == DT_FLAGS && (dyn.d_un.d_val & DF_TEXTREL))) {
+ 					if (is_textrel_rw)
+ 						vma->vm_flags |= VM_MAYWRITE;
+ 					else
+ 						/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+ 						vma->vm_flags &= ~VM_MAYWRITE;
+ 					break;
+ 				}
+ 				i++;
+ 			}
+ 			is_textrel_rw = false;
+ 			is_textrel_rx = false;
+ 			continue;
+ 
+ 		case PT_GNU_RELRO:
+ 			if (!is_relro)
+ 				continue;
+ 			if ((elf_p.p_offset >> PAGE_SHIFT) == vma->vm_pgoff && ELF_PAGEALIGN(elf_p.p_memsz) == vma->vm_end - vma->vm_start)
+ 				vma->vm_flags &= ~VM_MAYWRITE;
+ 			is_relro = false;
+ 			continue;
+ 
+ #ifdef CONFIG_MINISEC_PT_PAX_FLAGS
+ 		case PT_PAX_FLAGS: {
+ 			const char *msg_mprotect = "", *msg_emutramp = "";
+ 			char *buffer_lib, *buffer_exe;
+ 
+ 			if (elf_p.p_flags & PF_NOMPROTECT)
+ 				msg_mprotect = "MPROTECT disabled";
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 			if (!(vma->vm_mm->pax_flags & MF_PAX_EMUTRAMP) && !(elf_p.p_flags & PF_NOEMUTRAMP))
+ 				msg_emutramp = "EMUTRAMP enabled";
+ #endif
+ 
+ 			if (!msg_mprotect[0] && !msg_emutramp[0])
+ 				continue;
+ 
+ 			if (!printk_ratelimit())
+ 				continue;
+ 
+ 			buffer_lib = (char *)__get_free_page(GFP_KERNEL);
+ 			buffer_exe = (char *)__get_free_page(GFP_KERNEL);
+ 			if (buffer_lib && buffer_exe) {
+ 				char *path_lib, *path_exe;
+ 
+ 				path_lib = pax_get_path(&vma->vm_file->f_path, buffer_lib, PAGE_SIZE);
+ 				path_exe = pax_get_path(&vma->vm_mm->exe_file->f_path, buffer_exe, PAGE_SIZE);
+ 
+ 				pr_info("PAX: %s wants %s%s%s on %s\n", path_lib, msg_mprotect,
+ 					(msg_mprotect[0] && msg_emutramp[0] ? " and " : ""), msg_emutramp, path_exe);
+ 
+ 			}
+ 			free_page((unsigned long)buffer_exe);
+ 			free_page((unsigned long)buffer_lib);
+ 			continue;
+ 		}
+ #endif
+ 
+ 		}
+ 	}
+ }
+ #endif
+ 
  static int __init init_elf_binfmt(void)
  {
  	register_binfmt(&elf_format);
diff -rcNP og/fs/dcache.c patched/fs/dcache.c
*** og/fs/dcache.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/dcache.c	2021-03-13 14:02:45.000000000 +0200
***************
*** 268,274 ****
  {
  	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
  
! 	kmem_cache_free(dentry_cache, dentry); 
  }
  
  static void __d_free_external(struct rcu_head *head)
--- 268,274 ----
  {
  	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
  
! 	kmem_cache_free(dentry_cache, dentry);
  }
  
  static void __d_free_external(struct rcu_head *head)
***************
*** 811,817 ****
  }
  
  
! /* 
   * This is dput
   *
   * This is complicated by the fact that we do not want to put
--- 811,817 ----
  }
  
  
! /*
   * This is dput
   *
   * This is complicated by the fact that we do not want to put
***************
*** 830,836 ****
  
  /*
   * dput - release a dentry
!  * @dentry: dentry to release 
   *
   * Release a dentry. This will drop the usage count and if appropriate
   * call the dentry unlink method as well as removing it from the queues and
--- 830,836 ----
  
  /*
   * dput - release a dentry
!  * @dentry: dentry to release
   *
   * Release a dentry. This will drop the usage count and if appropriate
   * call the dentry unlink method as well as removing it from the queues and
***************
*** 1680,1686 ****
   * available. On a success the dentry is returned. The name passed in is
   * copied and the copy passed in may be reused after this call.
   */
!  
  struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
  {
  	struct dentry *dentry;
--- 1680,1686 ----
   * available. On a success the dentry is returned. The name passed in is
   * copied and the copy passed in may be reused after this call.
   */
! 
  struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
  {
  	struct dentry *dentry;
***************
*** 1707,1720 ****
  						  GFP_KERNEL_ACCOUNT |
  						  __GFP_RECLAIMABLE);
  		if (!p) {
! 			kmem_cache_free(dentry_cache, dentry); 
  			return NULL;
  		}
  		atomic_set(&p->u.count, 1);
  		dname = p->name;
  	} else  {
  		dname = dentry->d_iname;
! 	}	
  
  	dentry->d_name.len = name->len;
  	dentry->d_name.hash = name->hash;
--- 1707,1720 ----
  						  GFP_KERNEL_ACCOUNT |
  						  __GFP_RECLAIMABLE);
  		if (!p) {
! 			kmem_cache_free(dentry_cache, dentry);
  			return NULL;
  		}
  		atomic_set(&p->u.count, 1);
  		dname = p->name;
  	} else  {
  		dname = dentry->d_iname;
! 	}
  
  	dentry->d_name.len = name->len;
  	dentry->d_name.hash = name->hash;
***************
*** 1733,1738 ****
--- 1733,1741 ----
  	dentry->d_sb = sb;
  	dentry->d_op = NULL;
  	dentry->d_fsdata = NULL;
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	atomic_set(&dentry->chroot_refcnt, 0);
+ #endif
  	INIT_HLIST_BL_NODE(&dentry->d_hash);
  	INIT_LIST_HEAD(&dentry->d_lru);
  	INIT_LIST_HEAD(&dentry->d_subdirs);
***************
*** 1946,1952 ****
   * (or otherwise set) by the caller to indicate that it is now
   * in use by the dcache.
   */
!  
  void d_instantiate(struct dentry *entry, struct inode * inode)
  {
  	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
--- 1949,1955 ----
   * (or otherwise set) by the caller to indicate that it is now
   * in use by the dcache.
   */
! 
  void d_instantiate(struct dentry *entry, struct inode * inode)
  {
  	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
***************
*** 2156,2162 ****
  		if (!found) {
  			iput(inode);
  			return ERR_PTR(-ENOMEM);
! 		} 
  	}
  	res = d_splice_alias(inode, found);
  	if (res) {
--- 2159,2165 ----
  		if (!found) {
  			iput(inode);
  			return ERR_PTR(-ENOMEM);
! 		}
  	}
  	res = d_splice_alias(inode, found);
  	if (res) {
***************
*** 2365,2371 ****
  	 * See Documentation/filesystems/path-lookup.txt for more details.
  	 */
  	rcu_read_lock();
! 	
  	hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {
  
  		if (dentry->d_name.hash != hash)
--- 2368,2374 ----
  	 * See Documentation/filesystems/path-lookup.txt for more details.
  	 */
  	rcu_read_lock();
! 
  	hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {
  
  		if (dentry->d_name.hash != hash)
***************
*** 2428,2434 ****
   * it from the hash queues and waiting for
   * it to be deleted later when it has no users
   */
!  
  /**
   * d_delete - delete a dentry
   * @dentry: The dentry to delete
--- 2431,2437 ----
   * it from the hash queues and waiting for
   * it to be deleted later when it has no users
   */
! 
  /**
   * d_delete - delete a dentry
   * @dentry: The dentry to delete
***************
*** 2436,2442 ****
   * Turn the dentry into a negative dentry if possible, otherwise
   * remove it from the hash queues so it can be deleted later
   */
!  
  void d_delete(struct dentry * dentry)
  {
  	struct inode *inode = dentry->d_inode;
--- 2439,2445 ----
   * Turn the dentry into a negative dentry if possible, otherwise
   * remove it from the hash queues so it can be deleted later
   */
! 
  void d_delete(struct dentry * dentry)
  {
  	struct inode *inode = dentry->d_inode;
***************
*** 2472,2478 ****
   *
   * Adds a dentry to the hash according to its name.
   */
!  
  void d_rehash(struct dentry * entry)
  {
  	spin_lock(&entry->d_lock);
--- 2475,2481 ----
   *
   * Adds a dentry to the hash according to its name.
   */
! 
  void d_rehash(struct dentry * entry)
  {
  	spin_lock(&entry->d_lock);
***************
*** 3063,3069 ****
   * Returns false otherwise.
   * Caller must ensure that "new_dentry" is pinned before calling is_subdir()
   */
!   
  bool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)
  {
  	bool result;
--- 3066,3072 ----
   * Returns false otherwise.
   * Caller must ensure that "new_dentry" is pinned before calling is_subdir()
   */
! 
  bool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)
  {
  	bool result;
diff -rcNP og/fs/debugfs/inode.c patched/fs/debugfs/inode.c
*** og/fs/debugfs/inode.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/debugfs/inode.c	2021-03-13 14:05:08.000000000 +0200
***************
*** 547,552 ****
--- 547,557 ----
   * If debugfs is not enabled in the kernel, the value -%ENODEV will be
   * returned.
   */
+ 
+ #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
+ extern int grsec_enable_sysfs_restrict;
+ #endif
+ 
  struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)
  {
  	struct dentry *dentry = start_creating(name, parent);
***************
*** 561,568 ****
  		       name);
  		return failed_creating(dentry);
  	}
! 
! 	inode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
  	inode->i_op = &debugfs_dir_inode_operations;
  	inode->i_fop = &simple_dir_operations;
  
--- 566,578 ----
  		       name);
  		return failed_creating(dentry);
  	}
! 	
! #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
! 	if (grsec_enable_sysfs_restrict)
! 		inode->i_mode = S_IFDIR | S_IRWXU;
! 	else
! #endif
! 		inode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
  	inode->i_op = &debugfs_dir_inode_operations;
  	inode->i_fop = &simple_dir_operations;
  
***************
*** 913,916 ****
  	return retval;
  }
  core_initcall(debugfs_init);
- 
--- 923,925 ----
diff -rcNP og/fs/exec.c patched/fs/exec.c
*** og/fs/exec.c	2021-03-13 19:47:09.000000000 +0200
--- patched/fs/exec.c	2021-03-13 14:11:57.000000000 +0200
***************
*** 65,72 ****
--- 65,81 ----
  #include <linux/compat.h>
  #include <linux/vmalloc.h>
  #include <linux/random.h>
+ #include <linux/seq_file.h>
+ #include <linux/coredump.h>
+ #include <linux/mman.h>
+ 
+ #ifdef CONFIG_MINISEC
+ #include <linux/minisec.h>
+ #endif
+ #include <linux/random.h>
  
  #include <linux/uaccess.h>
+ #include <asm/sections.h>
  #include <asm/mmu_context.h>
  #include <asm/tlb.h>
  
***************
*** 278,283 ****
--- 287,298 ----
  	arch_bprm_mm_init(mm, vma);
  	up_write(&mm->mmap_sem);
  	bprm->p = vma->vm_end - sizeof(void *);
+ 
+ #ifdef CONFIG_MINISEC_RANDUSTACK
+ 	if (randomize_va_space)
+ 		bprm->p ^= prandom_u32() & ~PAGE_MASK;
+ #endif
+ 
  	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
  		bprm->p ^= get_random_int() & ~PAGE_MASK;
  	return 0;
***************
*** 748,753 ****
--- 763,780 ----
  
  	vm_flags = VM_STACK_FLAGS;
  
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ 	if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+ 		vm_flags &= ~VM_EXEC;
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 		if (mm->pax_flags & MF_PAX_MPROTECT)
+ 			vm_flags &= ~VM_MAYEXEC;
+ #endif
+ 
+ 	}
+ #endif
+ 
  	/*
  	 * Adjust stack execute permissions; explicitly enable for
  	 * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone
***************
*** 756,762 ****
--- 783,794 ----
  	if (unlikely(executable_stack == EXSTACK_ENABLE_X))
  		vm_flags |= VM_EXEC;
  	else if (executable_stack == EXSTACK_DISABLE_X)
+ 	{
  		vm_flags &= ~VM_EXEC;
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 		vm_flags &= ~VM_MAYEXEC;
+ #endif
+ 	}
  	vm_flags |= mm->def_flags;
  	vm_flags |= VM_STACK_INCOMPLETE_SETUP;
  
***************
*** 2028,2030 ****
--- 2060,2193 ----
  				  argv, envp, flags);
  }
  #endif
+ 
+ int pax_check_flags(unsigned long *flags)
+ {
+ 	int retval = 0;
+ 
+ #if !defined(CONFIG_X86_32) || !defined(CONFIG_MINISEC_SEGMEXEC)
+ 	if (*flags & MF_PAX_SEGMEXEC)
+ 	{
+ 		*flags &= ~MF_PAX_SEGMEXEC;
+ 		retval = -EINVAL;
+ 	}
+ #endif
+ 
+ 	if ((*flags & MF_PAX_PAGEEXEC)
+ 
+ #ifdef CONFIG_MINISEC_PAGEEXEC
+ 	    &&  (*flags & MF_PAX_SEGMEXEC)
+ #endif
+ 
+ 	   )
+ 	{
+ 		*flags &= ~MF_PAX_PAGEEXEC;
+ 		retval = -EINVAL;
+ 	}
+ 
+ 	if ((*flags & MF_PAX_MPROTECT)
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+ #endif
+ 
+ 	   )
+ 	{
+ 		*flags &= ~MF_PAX_MPROTECT;
+ 		retval = -EINVAL;
+ 	}
+ 
+ 	if ((*flags & MF_PAX_EMUTRAMP)
+ 
+ #ifdef CONFIG_MINISEC_EMUTRAMP
+ 	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+ #endif
+ 
+ 	   )
+ 	{
+ 		*flags &= ~MF_PAX_EMUTRAMP;
+ 		retval = -EINVAL;
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ EXPORT_SYMBOL(pax_check_flags);
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ char *pax_get_path(const struct path *path, char *buf, int buflen)
+ {
+ 	char *pathname = d_path(path, buf, buflen);
+ 
+ 	if (IS_ERR(pathname))
+ 		goto toolong;
+ 
+ 	pathname = mangle_path(buf, pathname, "\t\n\\");
+ 	if (!pathname)
+ 		goto toolong;
+ 
+ 	*pathname = 0;
+ 	return buf;
+ 
+ toolong:
+ 	return "<path too long>";
+ }
+ EXPORT_SYMBOL(pax_get_path);
+ 
+ void pax_report_fault(struct pt_regs *regs, void *pc, void *sp)
+ {
+ 	struct task_struct *tsk = current;
+ 	struct mm_struct *mm = current->mm;
+ 	char *buffer_exec = (char *)__get_free_page(GFP_KERNEL);
+ 	char *buffer_fault = (char *)__get_free_page(GFP_KERNEL);
+ 	char *path_exec = NULL;
+ 	char *path_fault = NULL;
+ 	unsigned long start = 0UL, end = 0UL, offset = 0UL;
+ 	kernel_siginfo_t info = { };
+ 
+ 	if (buffer_exec && buffer_fault) {
+ 		struct vm_area_struct *vma, *vma_exec = NULL, *vma_fault = NULL;
+ 
+ 		//down_read(&mm->mmap_sem);
+ 		vma = mm->mmap;
+ 		while (vma && (!vma_exec || !vma_fault)) {
+ 			if (vma->vm_file && mm->exe_file == vma->vm_file && (vma->vm_flags & VM_EXEC))
+ 				vma_exec = vma;
+ 			if (vma->vm_start <= (unsigned long)pc && (unsigned long)pc < vma->vm_end)
+ 				vma_fault = vma;
+ 			vma = vma->vm_next;
+ 		}
+ 		if (vma_exec)
+ 			path_exec = pax_get_path(&vma_exec->vm_file->f_path, buffer_exec, PAGE_SIZE);
+ 		if (vma_fault) {
+ 			start = vma_fault->vm_start;
+ 			end = vma_fault->vm_end;
+ 			offset = vma_fault->vm_pgoff << PAGE_SHIFT;
+ 			if (vma_fault->vm_file)
+ 				path_fault = pax_get_path(&vma_fault->vm_file->f_path, buffer_fault, PAGE_SIZE);
+ 			else if ((unsigned long)pc >= mm->start_brk && (unsigned long)pc < mm->brk)
+ 				path_fault = "<heap>";
+ 			else if (vma_fault->vm_flags & (VM_GROWSDOWN | VM_GROWSUP))
+ 				path_fault = "<stack>";
+ 			else
+ 				path_fault = "<anonymous mapping>";
+ 		}
+ 		//up_read(&mm->mmap_sem);
+ 	}
+ 	if (tsk->signal->curr_ip)
+ 		printk(KERN_ERR "PAX: From %pI4: execution attempt in: %s, %08lx-%08lx %08lx\n", &tsk->signal->curr_ip, path_fault, start, end, offset);
+ 	else
+ 		printk(KERN_ERR "PAX: execution attempt in: %s, %08lx-%08lx %08lx\n", path_fault, start, end, offset);
+ 	printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, PC: %p, SP: %p\n", path_exec, tsk->comm, task_pid_nr(tsk),
+ 			from_kuid_munged(&init_user_ns, task_uid(tsk)), from_kuid_munged(&init_user_ns, task_euid(tsk)), pc, sp);
+ 	free_page((unsigned long)buffer_exec);
+ 	free_page((unsigned long)buffer_fault);
+ 	pax_report_insns(regs, pc, sp);
+ 	info.si_signo = SIGKILL;
+ 	info.si_errno = 0;
+ 	info.si_code = SI_KERNEL;
+ 	info.si_pid = 0;
+ 	info.si_uid = 0;
+ 	do_coredump(&info);
+ }
+ #endif
diff -rcNP og/fs/fcntl.c patched/fs/fcntl.c
*** og/fs/fcntl.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/fcntl.c	2021-03-13 14:12:49.000000000 +0200
***************
*** 25,30 ****
--- 25,31 ----
  #include <linux/user_namespace.h>
  #include <linux/memfd.h>
  #include <linux/compat.h>
+ #include <linux/minisec.h>
  
  #include <linux/poll.h>
  #include <asm/siginfo.h>
***************
*** 106,111 ****
--- 107,114 ----
  		int force)
  {
  	security_file_set_fowner(filp);
+ 	if (gr_handle_chroot_fowner(pid, type))
+ 		return;
  	f_modown(filp, pid, type, force);
  }
  EXPORT_SYMBOL(__f_setown);
***************
*** 446,452 ****
  }
  
  SYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
! {	
  	struct fd f = fdget_raw(fd);
  	long err = -EBADF;
  
--- 449,455 ----
  }
  
  SYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
! {
  	struct fd f = fdget_raw(fd);
  	long err = -EBADF;
  
***************
*** 471,477 ****
  #if BITS_PER_LONG == 32
  SYSCALL_DEFINE3(fcntl64, unsigned int, fd, unsigned int, cmd,
  		unsigned long, arg)
! {	
  	void __user *argp = (void __user *)arg;
  	struct fd f = fdget_raw(fd);
  	struct flock64 flock;
--- 474,480 ----
  #if BITS_PER_LONG == 32
  SYSCALL_DEFINE3(fcntl64, unsigned int, fd, unsigned int, cmd,
  		unsigned long, arg)
! {
  	void __user *argp = (void __user *)arg;
  	struct fd f = fdget_raw(fd);
  	struct flock64 flock;
***************
*** 488,494 ****
  	err = security_file_fcntl(f.file, cmd, arg);
  	if (err)
  		goto out1;
! 	
  	switch (cmd) {
  	case F_GETLK64:
  	case F_OFD_GETLK:
--- 491,497 ----
  	err = security_file_fcntl(f.file, cmd, arg);
  	if (err)
  		goto out1;
! 
  	switch (cmd) {
  	case F_GETLK64:
  	case F_OFD_GETLK:
***************
*** 738,745 ****
  		kernel_siginfo_t si;
  		default:
  			/* Queue a rt signal with the appropriate fd as its
! 			   value.  We use SI_SIGIO as the source, not 
! 			   SI_KERNEL, since kernel signals always get 
  			   delivered even if we can't queue.  Failure to
  			   queue in this case _should_ be reported; we fall
  			   back to SIGIO in that case. --sct */
--- 741,748 ----
  		kernel_siginfo_t si;
  		default:
  			/* Queue a rt signal with the appropriate fd as its
! 			   value.  We use SI_SIGIO as the source, not
! 			   SI_KERNEL, since kernel signals always get
  			   delivered even if we can't queue.  Failure to
  			   queue in this case _should_ be reported; we fall
  			   back to SIGIO in that case. --sct */
***************
*** 781,787 ****
  	enum pid_type type;
  	unsigned long flags;
  	struct pid *pid;
! 	
  	read_lock_irqsave(&fown->lock, flags);
  
  	type = fown->pid_type;
--- 784,790 ----
  	enum pid_type type;
  	unsigned long flags;
  	struct pid *pid;
! 
  	read_lock_irqsave(&fown->lock, flags);
  
  	type = fown->pid_type;
***************
*** 820,826 ****
  	struct pid *pid;
  	unsigned long flags;
  	int ret = 0;
! 	
  	read_lock_irqsave(&fown->lock, flags);
  
  	type = fown->pid_type;
--- 823,829 ----
  	struct pid *pid;
  	unsigned long flags;
  	int ret = 0;
! 
  	read_lock_irqsave(&fown->lock, flags);
  
  	type = fown->pid_type;
diff -rcNP og/fs/namei.c patched/fs/namei.c
*** og/fs/namei.c	2021-03-13 19:47:09.000000000 +0200
--- patched/fs/namei.c	2021-03-13 14:14:32.000000000 +0200
***************
*** 39,44 ****
--- 39,45 ----
  #include <linux/bitops.h>
  #include <linux/init_task.h>
  #include <linux/uaccess.h>
+ #include <linux/minisec.h>
  
  #include "internal.h"
  #include "mount.h"
***************
*** 52,59 ****
   * The new code replaces the old recursive symlink resolution with
   * an iterative one (in case of non-nested symlink chains).  It does
   * this with calls to <fs>_follow_link().
!  * As a side effect, dir_namei(), _namei() and follow_link() are now 
!  * replaced with a single function lookup_dentry() that can handle all 
   * the special cases of the former code.
   *
   * With the new dcache, the pathname is stored at each inode, at least as
--- 53,60 ----
   * The new code replaces the old recursive symlink resolution with
   * an iterative one (in case of non-nested symlink chains).  It does
   * this with calls to <fs>_follow_link().
!  * As a side effect, dir_namei(), _namei() and follow_link() are now
!  * replaced with a single function lookup_dentry() that can handle all
   * the special cases of the former code.
   *
   * With the new dcache, the pathname is stored at each inode, at least as
***************
*** 3751,3756 ****
--- 3752,3763 ----
  
  	if (!IS_POSIXACL(path.dentry->d_inode))
  		mode &= ~current_umask();
+ 
+ 	if (gr_handle_chroot_mknod(dentry, path.mnt, mode)) {
+ 		error = -EPERM;
+ 		goto out;
+ 	}
+ 
  	error = security_path_mknod(&path, dentry, mode, dev);
  	if (error)
  		goto out;
diff -rcNP og/fs/namespace.c patched/fs/namespace.c
*** og/fs/namespace.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/namespace.c	2021-03-13 14:16:27.000000000 +0200
***************
*** 30,35 ****
--- 30,36 ----
  #include <uapi/linux/mount.h>
  #include <linux/fs_context.h>
  #include <linux/shmem_fs.h>
+ #include <linux/minisec.h>
  
  #include "pnode.h"
  #include "internal.h"
***************
*** 3130,3135 ****
--- 3131,3140 ----
  			    SB_LAZYTIME |
  			    SB_I_VERSION);
  
+ 	if (gr_handle_chroot_mount(path->dentry, path->mnt, dev_name)) {
+ 		return -EPERM;
+ 	}
+ 
  	if ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))
  		retval = do_reconfigure_mnt(&path, mnt_flags);
  	else if (flags & MS_REMOUNT)
***************
*** 3641,3646 ****
--- 3646,3655 ----
  	if (error)
  		goto out2;
  
+ 	if (gr_handle_chroot_pivot()) {
+ 		error = -EPERM;
+ 		goto out2;
+ 	}
  	get_fs_root(current->fs, &root);
  	old_mp = lock_mount(&old);
  	error = PTR_ERR(old_mp);
diff -rcNP og/fs/open.c patched/fs/open.c
*** og/fs/open.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/open.c	2021-03-13 14:18:55.000000000 +0200
***************
*** 32,37 ****
--- 32,38 ----
  #include <linux/ima.h>
  #include <linux/dnotify.h>
  #include <linux/compat.h>
+ #include <linux/minisec.h>
  
  #include "internal.h"
  
***************
*** 524,530 ****
--- 525,536 ----
  	if (error)
  		goto dput_and_out;
  
+ 	if (gr_handle_chroot_chroot(path.dentry, path.mnt))
+ 		goto dput_and_out;
  	set_fs_root(current->fs, &path);
+ 
+ 	gr_handle_chroot_chdir(&path);
+ 
  	error = 0;
  dput_and_out:
  	path_put(&path);
***************
*** 553,558 ****
--- 559,570 ----
  		return error;
  retry_deleg:
  	inode_lock(inode);
+ 
+ 	if (gr_handle_chroot_chmod(path->dentry, path->mnt, mode)) {
+ 		error = -EACCES;
+ 		goto out_unlock;
+ 	}
+ 
  	error = security_path_chmod(path, mode);
  	if (error)
  		goto out_unlock;
***************
*** 1056,1062 ****
  {
  	struct filename *name = getname_kernel(filename);
  	struct file *file = ERR_CAST(name);
! 	
  	if (!IS_ERR(name)) {
  		file = file_open_name(name, flags, mode);
  		putname(name);
--- 1068,1074 ----
  {
  	struct filename *name = getname_kernel(filename);
  	struct file *file = ERR_CAST(name);
! 
  	if (!IS_ERR(name)) {
  		file = file_open_name(name, flags, mode);
  		putname(name);
diff -rcNP og/fs/proc/array.c patched/fs/proc/array.c
*** og/fs/proc/array.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/array.c	2021-03-13 14:20:37.000000000 +0200
***************
*** 401,406 ****
--- 401,421 ----
  	seq_printf(m, "THP_enabled:\t%d\n", thp_enabled);
  }
  
+ #if defined(CONFIG_MINISEC_NOEXEC) || defined(CONFIG_MINISEC_ASLR)
+ static inline void task_pax(struct seq_file *m, struct task_struct *p)
+ {
+ 	if (p->mm)
+ 		seq_printf(m, "PaX:\t%c%c%c%c%c\n",
+ 			   p->mm->pax_flags & MF_PAX_PAGEEXEC ? 'P' : 'p',
+ 			   p->mm->pax_flags & MF_PAX_EMUTRAMP ? 'E' : 'e',
+ 			   p->mm->pax_flags & MF_PAX_MPROTECT ? 'M' : 'm',
+ 			   p->mm->pax_flags & MF_PAX_RANDMMAP ? 'R' : 'r',
+ 			   p->mm->pax_flags & MF_PAX_SEGMEXEC ? 'S' : 's');
+ 	else
+ 		seq_printf(m, "PaX:\t-----\n");
+ }
+ #endif
+ 
  int proc_pid_status(struct seq_file *m, struct pid_namespace *ns,
  			struct pid *pid, struct task_struct *task)
  {
***************
*** 424,429 ****
--- 439,449 ----
  	task_cpus_allowed(m, task);
  	cpuset_task_status_allowed(m, task);
  	task_context_switch_counts(m, task);
+ 
+ #if defined(CONFIG_MINISEC_NOEXEC) || defined(CONFIG_MINISEC_ASLR)
+ 	task_pax(m, task);
+ #endif
+ 
  	return 0;
  }
  
diff -rcNP og/fs/proc/base.c patched/fs/proc/base.c
*** og/fs/proc/base.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/base.c	2021-03-13 14:56:55.000000000 +0200
***************
*** 94,99 ****
--- 94,100 ----
  #include <linux/sched/debug.h>
  #include <linux/sched/stat.h>
  #include <linux/posix-timers.h>
+ #include <linux/minisec.h>
  #include <trace/events/oom.h>
  #include "internal.h"
  #include "fd.h"
***************
*** 699,704 ****
--- 700,729 ----
  				 struct task_struct *task,
  				 int hide_pid_min)
  {
+ 	if (gr_pid_is_chrooted(task))
+ 	return false;
+ 
+ #if defined(CONFIG_MINISEC_PROC_USER) || defined(CONFIG_MINISEC_PROC_USERGROUP)
+ rcu_read_lock();
+ {
+ 	const struct cred *tmpcred = current_cred();
+ 	const struct cred *cred = __task_cred(task);
+ 
+ 	if (uid_eq(tmpcred->uid, GLOBAL_ROOT_UID) || uid_eq(tmpcred->uid, cred->uid)
+ #ifdef CONFIG_MINISEC_PROC_USERGROUP
+ 		|| in_group_p(grsec_proc_gid)
+ #endif
+ 	) {
+ 		rcu_read_unlock();
+ 		return true;
+ 	}
+ }
+ rcu_read_unlock();
+ 
+ if (!fs_info->hide_pid)
+ 	return ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
+ #endif
+ 
  	if (pid->hide_pid < hide_pid_min)
  		return true;
  	if (in_group_p(pid->pid_gid))
***************
*** 719,725 ****
--- 744,754 ----
  	has_perms = has_pid_permissions(pid, task, HIDEPID_NO_ACCESS);
  	put_task_struct(task);
  
+ #if defined(CONFIG_MINISEC_PROC_USER) || defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 		{
+ #else
  	if (!has_perms) {
+ #endif
  		if (pid->hide_pid == HIDEPID_INVISIBLE) {
  			/*
  			 * Let's make getdents(), stat(), and open()
***************
*** 1704,1710 ****
--- 1733,1743 ----
  	rcu_read_lock();
  	cred = __task_cred(task);
  	uid = cred->euid;
+ #ifdef CONFIG_MINISEC_PROC_USERGROUP
+ 	gid = grsec_proc_gid;
+ #else
  	gid = cred->egid;
+ #endif
  	rcu_read_unlock();
  
  	/*
***************
*** 2472,2478 ****
  	return d_splice_alias(inode, dentry);
  }
  
! static struct dentry *proc_pident_lookup(struct inode *dir, 
  					 struct dentry *dentry,
  					 const struct pid_entry *p,
  					 const struct pid_entry *end)
--- 2505,2511 ----
  	return d_splice_alias(inode, dentry);
  }
  
! static struct dentry *proc_pident_lookup(struct inode *dir,
  					 struct dentry *dentry,
  					 const struct pid_entry *p,
  					 const struct pid_entry *end)
***************
*** 2483,2488 ****
--- 2516,2525 ----
  	if (!task)
  		goto out_no_task;
  
+ 	if (gr_pid_is_chrooted(task))
+ 		goto out_no_task;
+ 
+ 
  	/*
  	 * Yes, it does not scale. And it should not. Don't add
  	 * new entries into /proc/<tgid>/ without very good reasons.
***************
*** 2509,2514 ****
--- 2546,2553 ----
  	if (!task)
  		return -ENOENT;
  
+ 	if (gr_pid_is_chrooted(task))
+ 		goto out;
  	if (!dir_emit_dots(file, ctx))
  		goto out;
  
***************
*** 2659,2665 ****
  
  static int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)
  {
! 	return proc_pident_readdir(file, ctx, 
  				   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));
  }
  
--- 2698,2704 ----
  
  static int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)
  {
! 	return proc_pident_readdir(file, ctx,
  				   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));
  }
  
***************
*** 3223,3229 ****
--- 3262,3274 ----
  {
  	struct inode *inode;
  
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	inode = proc_pid_make_inode(dentry->d_sb, task, S_IFDIR | S_IRUSR | S_IXUSR);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	inode = proc_pid_make_inode(dentry->d_sb, task, S_IFDIR | S_IRUSR | S_IRGRP | S_IXUSR | S_IXGRP);
+ #else
  	inode = proc_pid_make_inode(dentry->d_sb, task, S_IFDIR | S_IRUGO | S_IXUGO);
+ #endif
  	if (!inode)
  		return ERR_PTR(-ENOENT);
  
***************
*** 3517,3523 ****
--- 3562,3575 ----
  	struct task_struct *task, const void *ptr)
  {
  	struct inode *inode;
+ 
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	inode = proc_pid_make_inode(dentry->d_sb, task, S_IFDIR | S_IRUSR | S_IXUSR);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	inode = proc_pid_make_inode(dentry->d_sb, task, S_IFDIR | S_IRUSR | S_IRGRP | S_IXUSR | S_IXGRP);
+ #else
  	inode = proc_pid_make_inode(dentry->d_sb, task, S_IFDIR | S_IRUGO | S_IXUGO);
+ #endif
  	if (!inode)
  		return ERR_PTR(-ENOENT);
  
diff -rcNP og/fs/proc/inode.c patched/fs/proc/inode.c
*** og/fs/proc/inode.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/inode.c	2021-03-13 14:58:53.000000000 +0200
***************
*** 24,29 ****
--- 24,30 ----
  #include <linux/seq_file.h>
  #include <linux/slab.h>
  #include <linux/mount.h>
+ #include <linux/minisec.h>
  
  #include <linux/uaccess.h>
  
***************
*** 462,468 ****
  		if (de->mode) {
  			inode->i_mode = de->mode;
  			inode->i_uid = de->uid;
! 			inode->i_gid = de->gid;
  		}
  		if (de->size)
  			inode->i_size = de->size;
--- 463,473 ----
  		if (de->mode) {
  			inode->i_mode = de->mode;
  			inode->i_uid = de->uid;
! #ifdef CONFIG_MINISEC_PROC_USERGROUP
! 			inode->i_gid = grsec_proc_gid;
! #else
!  			inode->i_gid = de->gid;
! #endif
  		}
  		if (de->size)
  			inode->i_size = de->size;
diff -rcNP og/fs/proc/kcore.c patched/fs/proc/kcore.c
*** og/fs/proc/kcore.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/kcore.c	2021-03-13 15:00:16.000000000 +0200
***************
*** 548,553 ****
--- 548,557 ----
  {
  	int ret = security_locked_down(LOCKDOWN_KCORE);
  
+ #if defined(CONFIG_MINISEC_PROC_ADD) || defined(CONFIG_MINISEC_HIDESYM)
+ 	return -EPERM;
+ #endif
+ 
  	if (!capable(CAP_SYS_RAWIO))
  		return -EPERM;
  
diff -rcNP og/fs/proc/proc_sysctl.c patched/fs/proc/proc_sysctl.c
*** og/fs/proc/proc_sysctl.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/proc_sysctl.c	2021-03-13 15:04:03.000000000 +0200
***************
*** 14,21 ****
--- 14,30 ----
  #include <linux/mm.h>
  #include <linux/module.h>
  #include <linux/bpf-cgroup.h>
+ #include <linux/minisec.h>
+ #include <linux/nsproxy.h>
+ #ifdef CONFIG_MINISEC
+ #include <net/net_namespace.h>
+ #endif
  #include "internal.h"
  
+ extern int gr_handle_chroot_sysctl(const int op);
+ extern int gr_handle_sysctl_mod(const char *dirname, const char *name,
+ 				const int op);
+ 
  static const struct dentry_operations proc_sys_dentry_operations;
  static const struct file_operations proc_sys_file_operations;
  static const struct inode_operations proc_sys_inode_operations;
***************
*** 579,584 ****
--- 588,594 ----
  	struct ctl_table_header *head = grab_header(inode);
  	struct ctl_table *table = PROC_I(inode)->sysctl_entry;
  	void *new_buf = NULL;
+ 	int op = write ? MAY_WRITE : MAY_READ;
  	ssize_t error;
  
  	if (IS_ERR(head))
***************
*** 589,595 ****
  	 * and won't be until we finish.
  	 */
  	error = -EPERM;
! 	if (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))
  		goto out;
  
  	/* if that can happen at all, it should be -EINVAL, not -EISDIR */
--- 599,605 ----
  	 * and won't be until we finish.
  	 */
  	error = -EPERM;
! 	if (sysctl_perm(head, table, op))
  		goto out;
  
  	/* if that can happen at all, it should be -EINVAL, not -EISDIR */
***************
*** 602,607 ****
--- 612,633 ----
  	if (error)
  		goto out;
  
+ #ifdef CONFIG_MINISEC
+ 	error = -EPERM;
+ 	if (gr_handle_chroot_sysctl(op))
+ 		goto out;
+ 	if (gr_handle_sysctl_mod(NULL, table->procname, op)) {
+ 		goto out;
+ 	}
+ 	if (write) {
+ 		if (current->nsproxy->net_ns != table->extra2) {
+ 			if (!capable(CAP_SYS_ADMIN))
+ 				goto out;
+ 		} else if (!ns_capable(current->nsproxy->net_ns->user_ns, CAP_NET_ADMIN))
+ 			goto out;
+ 	}
+ #endif
+ 
  	/* careful: calling conventions are nasty here */
  	if (new_buf) {
  		mm_segment_t old_fs;
diff -rcNP og/fs/proc/root.c patched/fs/proc/root.c
*** og/fs/proc/root.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/root.c	2021-03-13 15:05:18.000000000 +0200
***************
*** 118,124 ****
  	 * top of it
  	 */
  	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
! 	
  	/* procfs dentries and inodes don't require IO to create */
  	s->s_shrink.seeks = 0;
  
--- 118,124 ----
  	 * top of it
  	 */
  	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
! 
  	/* procfs dentries and inodes don't require IO to create */
  	s->s_shrink.seeks = 0;
  
***************
*** 229,235 ****
--- 229,243 ----
  	proc_create_mount_point("openprom");
  #endif
  	proc_tty_init();
+ #ifdef CONFIG_MINISEC_PROC_ADD
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	proc_mkdir_mode("bus", S_IRUSR | S_IXUSR, NULL);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	proc_mkdir_mode("bus", S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP, NULL);
+ #endif
+ #else
  	proc_mkdir("bus", NULL);
+ #endif
  	proc_sys_init();
  
  	register_filesystem(&proc_fs_type);
***************
*** 286,297 ****
   * This is the root "inode" in the /proc tree..
   */
  struct proc_dir_entry proc_root = {
! 	.low_ino	= PROC_ROOT_INO, 
! 	.namelen	= 5, 
! 	.mode		= S_IFDIR | S_IRUGO | S_IXUGO, 
! 	.nlink		= 2, 
  	.refcnt		= REFCOUNT_INIT(1),
! 	.proc_iops	= &proc_root_inode_operations, 
  	.proc_fops	= &proc_root_operations,
  	.parent		= &proc_root,
  	.subdir		= RB_ROOT,
--- 294,305 ----
   * This is the root "inode" in the /proc tree..
   */
  struct proc_dir_entry proc_root = {
! 	.low_ino	= PROC_ROOT_INO,
! 	.namelen	= 5,
! 	.mode		= S_IFDIR | S_IRUGO | S_IXUGO,
! 	.nlink		= 2,
  	.refcnt		= REFCOUNT_INIT(1),
! 	.proc_iops	= &proc_root_inode_operations,
  	.proc_fops	= &proc_root_operations,
  	.parent		= &proc_root,
  	.subdir		= RB_ROOT,
diff -rcNP og/fs/proc/stat.c patched/fs/proc/stat.c
*** og/fs/proc/stat.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/proc/stat.c	2021-03-13 15:12:28.000000000 +0200
***************
*** 13,18 ****
--- 13,19 ----
  #include <linux/irqnr.h>
  #include <linux/sched/cputime.h>
  #include <linux/tick.h>
+ #include <linux/minisec.h>
  
  #ifndef arch_irq_stat_cpu
  #define arch_irq_stat_cpu(cpu) 0
***************
*** 92,104 ****
  	}
  }
  
! static void show_all_irqs(struct seq_file *p)
  {
  	unsigned int i, next = 0;
  
  	for_each_active_irq(i) {
  		show_irq_gap(p, i - next);
! 		seq_put_decimal_ull(p, " ", kstat_irqs_usr(i));
  		next = i + 1;
  	}
  	show_irq_gap(p, nr_irqs - next);
--- 93,105 ----
  	}
  }
  
! static void show_all_irqs(struct seq_file *p, int unrestricted)
  {
  	unsigned int i, next = 0;
  
  	for_each_active_irq(i) {
  		show_irq_gap(p, i - next);
! 		seq_put_decimal_ull(p, " ", unrestricted ? kstat_irqs_usr(i) : 0ULL);
  		next = i + 1;
  	}
  	show_irq_gap(p, nr_irqs - next);
***************
*** 113,118 ****
--- 114,130 ----
  	u64 sum_softirq = 0;
  	unsigned int per_softirq_sums[NR_SOFTIRQS] = {0};
  	struct timespec64 boottime;
+ 	int unrestricted = 1;
+ #ifdef CONFIG_MINISEC_PROC_ADD
+ #if defined(CONFIG_MINISEC_PROC_USER) || defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)
+ #ifdef CONFIG_MINISEC_PROC_USERGROUP
+ 		&& !in_group_p(grsec_proc_gid)
+ #endif
+ 	)
+ 		unrestricted = 0;
+ #endif
+ #endif
  
  	user = nice = system = idle = iowait =
  		irq = softirq = steal = 0;
***************
*** 126,131 ****
--- 138,144 ----
  		nice += kcs->cpustat[CPUTIME_NICE];
  		system += kcs->cpustat[CPUTIME_SYSTEM];
  		idle += get_idle_time(kcs, i);
+ if (unrestricted) {
  		iowait += get_iowait_time(kcs, i);
  		irq += kcs->cpustat[CPUTIME_IRQ];
  		softirq += kcs->cpustat[CPUTIME_SOFTIRQ];
***************
*** 141,148 ****
  			per_softirq_sums[j] += softirq_stat;
  			sum_softirq += softirq_stat;
  		}
  	}
! 	sum += arch_irq_stat();
  
  	seq_put_decimal_ull(p, "cpu  ", nsec_to_clock_t(user));
  	seq_put_decimal_ull(p, " ", nsec_to_clock_t(nice));
--- 154,164 ----
  			per_softirq_sums[j] += softirq_stat;
  			sum_softirq += softirq_stat;
  		}
+ }
  	}
! 
! 	if (unrestricted)
! 		sum += arch_irq_stat();
  
  	seq_put_decimal_ull(p, "cpu  ", nsec_to_clock_t(user));
  	seq_put_decimal_ull(p, " ", nsec_to_clock_t(nice));
***************
*** 164,175 ****
--- 180,193 ----
  		nice = kcs->cpustat[CPUTIME_NICE];
  		system = kcs->cpustat[CPUTIME_SYSTEM];
  		idle = get_idle_time(kcs, i);
+ if (unrestricted) {
  		iowait = get_iowait_time(kcs, i);
  		irq = kcs->cpustat[CPUTIME_IRQ];
  		softirq = kcs->cpustat[CPUTIME_SOFTIRQ];
  		steal = kcs->cpustat[CPUTIME_STEAL];
  		guest = kcs->cpustat[CPUTIME_GUEST];
  		guest_nice = kcs->cpustat[CPUTIME_GUEST_NICE];
+ }
  		seq_printf(p, "cpu%d", i);
  		seq_put_decimal_ull(p, " ", nsec_to_clock_t(user));
  		seq_put_decimal_ull(p, " ", nsec_to_clock_t(nice));
***************
*** 185,203 ****
  	}
  	seq_put_decimal_ull(p, "intr ", (unsigned long long)sum);
  
! 	show_all_irqs(p);
  
  	seq_printf(p,
  		"\nctxt %llu\n"
  		"btime %llu\n"
! 		"processes %lu\n"
! 		"procs_running %lu\n"
! 		"procs_blocked %lu\n",
! 		nr_context_switches(),
  		(unsigned long long)boottime.tv_sec,
! 		total_forks,
! 		nr_running(),
! 		nr_iowait());
  
  	seq_put_decimal_ull(p, "softirq ", (unsigned long long)sum_softirq);
  
--- 203,221 ----
  	}
  	seq_put_decimal_ull(p, "intr ", (unsigned long long)sum);
  
! 	show_all_irqs(p, unrestricted);
  
  	seq_printf(p,
  		"\nctxt %llu\n"
  		"btime %llu\n"
! 		"processes %llu\n"
! 		"procs_running %llu\n"
! 		"procs_blocked %llu\n",
! 		unrestricted ? nr_context_switches() : 0ULL,
  		(unsigned long long)boottime.tv_sec,
! 		unrestricted ? total_forks : 0ULL,
! 		unrestricted ? nr_running() : 0ULL,
! 		unrestricted ? nr_iowait() : 0ULL);
  
  	seq_put_decimal_ull(p, "softirq ", (unsigned long long)sum_softirq);
  
diff -rcNP og/fs/sysfs/dir.c patched/fs/sysfs/dir.c
*** og/fs/sysfs/dir.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/sysfs/dir.c	2021-03-13 15:16:55.000000000 +0200
***************
*** 32,37 ****
--- 32,41 ----
  	kfree(buf);
  }
  
+ #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
+ extern int grsec_enable_sysfs_restrict;
+ #endif
+ 
  /**
   * sysfs_create_dir_ns - create a directory for an object with a namespace tag
   * @kobj: object we're creating directory for
***************
*** 42,51 ****
--- 46,62 ----
  	struct kernfs_node *parent, *kn;
  	kuid_t uid;
  	kgid_t gid;
+ 	const char *name;
+ 	umode_t mode = S_IRWXU | S_IRUGO | S_IXUGO;
+ #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
+ 	const char *parent_name;
+ #endif
  
  	if (WARN_ON(!kobj))
  		return -EINVAL;
  
+ 	name = kobject_name(kobj);
+ 
  	if (kobj->parent)
  		parent = kobj->parent->sd;
  	else
***************
*** 56,67 ****
  
  	kobject_get_ownership(kobj, &uid, &gid);
  
  	kn = kernfs_create_dir_ns(parent, kobject_name(kobj),
! 				  S_IRWXU | S_IRUGO | S_IXUGO, uid, gid,
  				  kobj, ns);
  	if (IS_ERR(kn)) {
  		if (PTR_ERR(kn) == -EEXIST)
! 			sysfs_warn_dup(parent, kobject_name(kobj));
  		return PTR_ERR(kn);
  	}
  
--- 67,92 ----
  
  	kobject_get_ownership(kobj, &uid, &gid);
  
+ #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
+ 	parent_name = parent->name;
+ 	mode = S_IRWXU;
+ 
+ 	if ((!strcmp(parent_name, "") && (!strcmp(name, "devices") || !strcmp(name, "fs"))) ||
+ 	    (!strcmp(parent_name, "devices") && !strcmp(name, "system")) ||
+ 	    (!strcmp(parent_name, "fs") && (!strcmp(name, "selinux") || !strcmp(name, "fuse") || !strcmp(name, "ecryptfs"))) ||
+ 	    (!strcmp(parent_name, "system") && !strcmp(name, "cpu")))
+ 		mode = S_IRWXU | S_IRUGO | S_IXUGO;
+ 	if (!grsec_enable_sysfs_restrict)
+ 		mode = S_IRWXU | S_IRUGO | S_IXUGO;
+ #endif
+ 
  	kn = kernfs_create_dir_ns(parent, kobject_name(kobj),
! 					mode, uid, gid,
  				  kobj, ns);
+ 
  	if (IS_ERR(kn)) {
  		if (PTR_ERR(kn) == -EEXIST)
! 			sysfs_warn_dup(parent, name);
  		return PTR_ERR(kn);
  	}
  
diff -rcNP og/fs/xattr.c patched/fs/xattr.c
*** og/fs/xattr.c	2021-03-11 15:06:51.000000000 +0200
--- patched/fs/xattr.c	2021-03-13 15:17:47.000000000 +0200
***************
*** 349,354 ****
--- 349,370 ----
  }
  EXPORT_SYMBOL(__vfs_getxattr);
  
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ ssize_t
+ pax_getxattr(struct dentry *dentry, void *value, size_t size)
+ {
+ 	struct inode *inode = dentry->d_inode;
+ 	ssize_t error;
+ 
+ 	error = inode_permission(inode, MAY_EXEC);
+ 	if (error)
+ 		return error;
+ 
+ 	return __vfs_getxattr(dentry, inode, XATTR_NAME_USER_PAX_FLAGS, value, size);
+ }
+ EXPORT_SYMBOL(pax_getxattr);
+ #endif
+ 
  ssize_t
  vfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)
  {
diff -rcNP og/include/linux/binfmts.h patched/include/linux/binfmts.h
*** og/include/linux/binfmts.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/binfmts.h	2021-03-13 15:19:18.000000000 +0200
***************
*** 105,110 ****
--- 105,113 ----
  	int (*load_binary)(struct linux_binprm *);
  	int (*load_shlib)(struct file *);
  	int (*core_dump)(struct coredump_params *cprm);
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	void (*handle_mprotect)(struct vm_area_struct *vma, unsigned long newflags);
+ #endif
  	unsigned long min_coredump;	/* minimal dump size */
  } __randomize_layout;
  
diff -rcNP og/include/linux/dcache.h patched/include/linux/dcache.h
*** og/include/linux/dcache.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/dcache.h	2021-03-13 15:20:07.000000000 +0200
***************
*** 108,113 ****
--- 108,116 ----
  		struct list_head d_lru;		/* LRU list */
  		wait_queue_head_t *d_wait;	/* in-lookup ones only */
  	};
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	atomic_t chroot_refcnt;		/* tracks use of directory in chroot */
+ #endif
  	struct list_head d_child;	/* child of parent list */
  	struct list_head d_subdirs;	/* our children */
  	/*
***************
*** 266,272 ****
   * This adds the entry to the hash queues.
   */
  extern void d_rehash(struct dentry *);
!  
  extern void d_add(struct dentry *, struct inode *);
  
  /* used for rename() and baskets */
--- 269,275 ----
   * This adds the entry to the hash queues.
   */
  extern void d_rehash(struct dentry *);
! 
  extern void d_add(struct dentry *, struct inode *);
  
  /* used for rename() and baskets */
***************
*** 305,311 ****
   *	@dentry: dentry to get a reference to
   *
   *	Given a dentry or %NULL pointer increment the reference count
!  *	if appropriate and return the dentry. A dentry will not be 
   *	destroyed when it has references.
   */
  static inline struct dentry *dget_dlock(struct dentry *dentry)
--- 308,314 ----
   *	@dentry: dentry to get a reference to
   *
   *	Given a dentry or %NULL pointer increment the reference count
!  *	if appropriate and return the dentry. A dentry will not be
   *	destroyed when it has references.
   */
  static inline struct dentry *dget_dlock(struct dentry *dentry)
***************
*** 330,336 ****
   *
   *	Returns true if the dentry passed is not currently hashed.
   */
!  
  static inline int d_unhashed(const struct dentry *dentry)
  {
  	return hlist_bl_unhashed(&dentry->d_hash);
--- 333,339 ----
   *
   *	Returns true if the dentry passed is not currently hashed.
   */
! 
  static inline int d_unhashed(const struct dentry *dentry)
  {
  	return hlist_bl_unhashed(&dentry->d_hash);
diff -rcNP og/include/linux/elf.h patched/include/linux/elf.h
*** og/include/linux/elf.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/elf.h	2021-03-13 15:21:18.000000000 +0200
***************
*** 31,36 ****
--- 31,37 ----
  #define elf_addr_t	Elf32_Off
  #define Elf_Half	Elf32_Half
  #define Elf_Word	Elf32_Word
+ #define elf_dyn		Elf32_Dyn
  
  #else
  
***************
*** 42,47 ****
--- 43,49 ----
  #define elf_addr_t	Elf64_Off
  #define Elf_Half	Elf64_Half
  #define Elf_Word	Elf64_Word
+ #define elf_dyn		Elf64_Dyn
  
  #endif
  
diff -rcNP og/include/linux/minisec.h patched/include/linux/minisec.h
*** og/include/linux/minisec.h	1970-01-01 03:00:00.000000000 +0300
--- patched/include/linux/minisec.h	2021-03-13 15:21:59.000000000 +0200
***************
*** 0 ****
--- 1,67 ----
+ #ifndef __MINISEC_H
+ #define __MINISEC_H
+ 
+ #include <linux/fs.h>
+ 
+ #define proc_is_chrooted(tsk_a)  ((tsk_a)->gr_is_chrooted)
+ #define have_same_root(tsk_a,tsk_b) ((tsk_a)->gr_chroot_dentry == (tsk_b)->gr_chroot_dentry)
+ #define GR_CHROOT_CAPS {{ \
+ 	CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_NET_ADMIN) | \
+ 	CAP_TO_MASK(CAP_SYS_MODULE) | CAP_TO_MASK(CAP_SYS_RAWIO) | \
+ 	CAP_TO_MASK(CAP_SYS_PACCT) | CAP_TO_MASK(CAP_SYS_ADMIN) | \
+ 	CAP_TO_MASK(CAP_SYS_BOOT) | CAP_TO_MASK(CAP_SYS_TIME) | \
+ 	CAP_TO_MASK(CAP_NET_RAW) | CAP_TO_MASK(CAP_SYS_TTY_CONFIG) | \
+ 	CAP_TO_MASK(CAP_IPC_OWNER) | CAP_TO_MASK(CAP_SETFCAP), \
+ 	CAP_TO_MASK(CAP_SYSLOG) | CAP_TO_MASK(CAP_MAC_ADMIN) }}
+ 
+ extern int grsec_enable_chroot_shmat;
+ extern int grsec_enable_chroot_mount;
+ extern int grsec_enable_chroot_double;
+ extern int grsec_enable_chroot_pivot;
+ extern int grsec_enable_chroot_chdir;
+ extern int grsec_enable_chroot_chmod;
+ extern int grsec_enable_chroot_mknod;
+ extern int grsec_enable_chroot_fchdir;
+ extern int grsec_enable_chroot_nice;
+ extern int grsec_enable_chroot_execlog;
+ extern int grsec_enable_chroot_caps;
+ extern int grsec_enable_chroot_rename;
+ extern int grsec_enable_chroot_sysctl;
+ extern int grsec_enable_chroot_unix;
+ extern int grsec_enable_harden_ipc;
+ extern int grsec_enable_harden_tty;
+ extern int grsec_lock;
+ 
+ int gr_handle_tiocsti(struct tty_struct *tty);
+ 
+ int gr_pid_is_chrooted(struct task_struct *p);
+ int gr_handle_chroot_fowner(struct pid *pid, enum pid_type type);
+ int gr_handle_chroot_nice(void);
+ int gr_handle_chroot_sysctl(const int op);
+ int gr_handle_chroot_setpriority(struct task_struct *p,
+ 					const int niceval);
+ int gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt);
+ int gr_chroot_pathat(int dfd, struct dentry *u_dentry, struct vfsmount *u_mnt, unsigned flags);
+ int gr_chroot_fhandle(void);
+ int gr_handle_chroot_chroot(const struct dentry *dentry,
+ 				   const struct vfsmount *mnt);
+ void gr_handle_chroot_chdir(const struct path *path);
+ int gr_handle_chroot_chmod(const struct dentry *dentry,
+ 				  const struct vfsmount *mnt, const int mode);
+ int gr_handle_chroot_mknod(const struct dentry *dentry,
+ 				  const struct vfsmount *mnt, const int mode);
+ int gr_handle_chroot_mount(const struct dentry *dentry,
+ 				  const struct vfsmount *mnt,
+ 				  const char *dev_name);
+ int gr_handle_chroot_pivot(void);
+ int gr_handle_chroot_unix(const pid_t pid);
+ 
+ #ifdef CONFIG_MINISEC_CHROOT_FINDTASK
+ extern int grsec_enable_chroot_findtask;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_PROC_USERGROUP
+ extern kgid_t grsec_proc_gid;
+ #endif
+ 
+ #endif
diff -rcNP og/include/linux/mm.h patched/include/linux/mm.h
*** og/include/linux/mm.h	2021-03-13 19:47:10.000000000 +0200
--- patched/include/linux/mm.h	2021-03-13 15:24:10.000000000 +0200
***************
*** 276,281 ****
--- 276,286 ----
  #define VM_ACCOUNT	0x00100000	/* Is a VM accounted object */
  #define VM_NORESERVE	0x00200000	/* should the VM suppress accounting */
  #define VM_HUGETLB	0x00400000	/* Huge TLB Page VM */
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(CONFIG_X86_32)
+ #define VM_PAGEEXEC	0x00800000	/* vma->vm_page_prot needs special handling */
+ #endif
+ 
  #define VM_SYNC		0x00800000	/* Synchronous page faults */
  #define VM_ARCH_1	0x01000000	/* Architecture-specific flag */
  #define VM_WIPEONFORK	0x02000000	/* Wipe VMA contents in child. */
diff -rcNP og/include/linux/mm_types.h patched/include/linux/mm_types.h
*** og/include/linux/mm_types.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/mm_types.h	2021-03-13 15:26:14.000000000 +0200
***************
*** 526,531 ****
--- 526,540 ----
  		struct work_struct async_put_work;
  	} __randomize_layout;
  
+ if defined(CONFIG_MINISEC)
+ 		unsigned long pax_flags;
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_ASLR
+ 	unsigned long delta_mmap;		/* randomized offset */
+ 	unsigned long delta_stack;		/* randomized offset */
+ #endif
+ 
  	/*
  	 * The mm_cpumask needs to be at the end of mm_struct, because it
  	 * is dynamically sized based on nr_cpu_ids.
diff -rcNP og/include/linux/proc_fs.h patched/include/linux/proc_fs.h
*** og/include/linux/proc_fs.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/proc_fs.h	2021-03-13 15:30:34.000000000 +0200
***************
*** 23,30 ****
--- 23,33 ----
  		struct proc_dir_entry *, const char *);
  struct proc_dir_entry *_proc_mkdir(const char *, umode_t, struct proc_dir_entry *, void *, bool);
  extern struct proc_dir_entry *proc_mkdir(const char *, struct proc_dir_entry *);
+ extern struct proc_dir_entry *proc_mkdir_restrict(const char *, struct proc_dir_entry *);
  extern struct proc_dir_entry *proc_mkdir_data(const char *, umode_t,
  					      struct proc_dir_entry *, void *);
+ extern struct proc_dir_entry *proc_mkdir_data_restrict(const char *, umode_t,
+ 					      struct proc_dir_entry *, void *);
  extern struct proc_dir_entry *proc_mkdir_mode(const char *, umode_t,
  					      struct proc_dir_entry *);
  struct proc_dir_entry *proc_create_mount_point(const char *name);
***************
*** 41,53 ****
  		int (*show)(struct seq_file *, void *), void *data);
  #define proc_create_single(name, mode, parent, show) \
  	proc_create_single_data(name, mode, parent, show, NULL)
!  
  extern struct proc_dir_entry *proc_create_data(const char *, umode_t,
  					       struct proc_dir_entry *,
  					       const struct file_operations *,
  					       void *);
  
  struct proc_dir_entry *proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops);
  extern void proc_set_size(struct proc_dir_entry *, loff_t);
  extern void proc_set_user(struct proc_dir_entry *, kuid_t, kgid_t);
  extern void *PDE_DATA(const struct inode *);
--- 44,69 ----
  		int (*show)(struct seq_file *, void *), void *data);
  #define proc_create_single(name, mode, parent, show) \
  	proc_create_single_data(name, mode, parent, show, NULL)
! 
  extern struct proc_dir_entry *proc_create_data(const char *, umode_t,
  					       struct proc_dir_entry *,
  					       const struct file_operations *,
  					       void *);
  
  struct proc_dir_entry *proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops);
+ 
+ static inline struct proc_dir_entry *proc_create_grsec(const char *name, umode_t mode,
+ 	struct proc_dir_entry *parent, const struct file_operations *proc_fops)
+ {
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	return proc_create_data(name, S_IRUSR, parent, (const struct proc_ops *)proc_fops, NULL);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	return proc_create_data(name, S_IRUSR | S_IRGRP, parent, (const struct proc_ops *)proc_fops, NULL);
+ #else
+ 	return proc_create_data(name, mode, parent, (const struct proc_ops *)proc_fops, NULL);
+ #endif
+ }
+ 
  extern void proc_set_size(struct proc_dir_entry *, loff_t);
  extern void proc_set_user(struct proc_dir_entry *, kuid_t, kgid_t);
  extern void *PDE_DATA(const struct inode *);
***************
*** 99,104 ****
--- 115,122 ----
  		struct proc_dir_entry *parent,const char *dest) { return NULL;}
  static inline struct proc_dir_entry *proc_mkdir(const char *name,
  	struct proc_dir_entry *parent) {return NULL;}
+ static inline struct proc_dir_entry *proc_mkdir_restrict(const char *name,
+ 	struct proc_dir_entry *parent) { return NULL; }
  static inline struct proc_dir_entry *proc_create_mount_point(const char *name) { return NULL; }
  static inline struct proc_dir_entry *_proc_mkdir(const char *name, umode_t mode,
  		struct proc_dir_entry *parent, void *data, bool force_lookup)
***************
*** 107,112 ****
--- 125,132 ----
  }
  static inline struct proc_dir_entry *proc_mkdir_data(const char *name,
  	umode_t mode, struct proc_dir_entry *parent, void *data) { return NULL; }
+ static inline  struct proc_dir_entry *proc_mkdir_data_restrict(const char *name,
+ 	umode_t mode, struct proc_dir_entry *parent, void *data) { return NULL; }
  static inline struct proc_dir_entry *proc_mkdir_mode(const char *name,
  	umode_t mode, struct proc_dir_entry *parent) { return NULL; }
  #define proc_create_seq_private(name, mode, parent, ops, size, data) ({NULL;})
diff -rcNP og/include/linux/random.h patched/include/linux/random.h
*** og/include/linux/random.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/random.h	2021-03-13 15:31:15.000000000 +0200
***************
*** 144,147 ****
--- 144,152 ----
  }
  #endif
  
+ static inline unsigned long pax_get_random_long(void)
+ {
+ 	return prandom_u32() + (sizeof(long) > 4 ? (unsigned long)prandom_u32() << 32 : 0);
+ }
+ 
  #endif /* _LINUX_RANDOM_H */
diff -rcNP og/include/linux/sched/signal.h patched/include/linux/sched/signal.h
*** og/include/linux/sched/signal.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/sched/signal.h	2021-03-13 15:35:29.000000000 +0200
***************
*** 206,211 ****
--- 206,220 ----
  #ifdef CONFIG_TASKSTATS
  	struct taskstats *stats;
  #endif
+ #ifdef CONFIG_MINISEC
+ 	u32 curr_ip;
+ 	u32 saved_ip;
+ 	u32 gr_saddr;
+ 	u32 gr_daddr;
+ 	u16 gr_sport;
+ 	u16 gr_dport;
+ 	u8 used_accept:1;
+ #endif
  #ifdef CONFIG_AUDIT
  	unsigned audit_tty;
  	struct tty_audit_buf *tty_audit_buf;
diff -rcNP og/include/linux/sched.h patched/include/linux/sched.h
*** og/include/linux/sched.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/sched.h	2021-03-13 15:34:11.000000000 +0200
***************
*** 27,32 ****
--- 27,33 ----
  #include <linux/sched/prio.h>
  #include <linux/sched/types.h>
  #include <linux/signal_types.h>
+ #include <linux/mm_types.h>
  #include <linux/mm_types_task.h>
  #include <linux/task_io_accounting.h>
  #include <linux/posix-timers.h>
***************
*** 1268,1273 ****
--- 1269,1279 ----
  	unsigned long			prev_lowest_stack;
  #endif
  
+ ifdef CONFIG_MINISEC
+ 	struct dentry *gr_chroot_dentry;
+ 	u8 gr_is_chrooted;
+ #endif
+ 
  	/*
  	 * New fields for task_struct should be added above here, so that
  	 * they are included in the randomized portion of task_struct.
***************
*** 1662,1668 ****
   * see also find_vpid() etc in include/linux/pid.h
   */
  
! extern struct task_struct *find_task_by_vpid(pid_t nr);
  extern struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns);
  
  /*
--- 1668,1674 ----
   * see also find_vpid() etc in include/linux/pid.h
   */
  
! extern struct task_struct *find_task_by_vpid_unrestricted(pid_t nr);
  extern struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns);
  
  /*
***************
*** 1857,1862 ****
--- 1863,1907 ----
  #define TASK_SIZE_OF(tsk)	TASK_SIZE
  #endif
  
+ #define MF_PAX_PAGEEXEC		0x01000000	/* Paging based non-executable pages */
+ #define MF_PAX_EMUTRAMP		0x02000000	/* Emulate trampolines */
+ #define MF_PAX_MPROTECT		0x04000000	/* Restrict mprotect() */
+ #define MF_PAX_RANDMMAP		0x08000000	/* Randomize mmap() base */
+ #define MF_PAX_SEGMEXEC		0x20000000	/* Segmentation based non-executable pages */
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ extern int pax_softmode;
+ #endif
+ 
+ extern int pax_check_flags(unsigned long *);
+ #define PAX_PARSE_FLAGS_FALLBACK	(~0UL)
+ 
+ /* if tsk != current then task_lock must be held on it */
+ #if defined(CONFIG_MINISEC_NOEXEC) || defined(CONFIG_MINISEC_ASLR)
+ static inline unsigned long pax_get_flags(struct task_struct *tsk)
+ {
+ 	if (likely(tsk))
+ 		return tsk->mm->pax_flags;
+ 	else
+ 		return 0UL;
+ }
+ 
+ /* if tsk != current then task_lock must be held on it */
+ static inline long pax_set_flags(struct task_struct *tsk, unsigned long flags)
+ {
+ 	if (likely(tsk)) {
+ 		tsk->mm->pax_flags = flags;
+ 		return 0;
+ 	}
+ 	return -EINVAL;
+ }
+ #endif
+ 
+ struct path;
+ extern char *pax_get_path(const struct path *path, char *buf, int buflen);
+ extern void pax_report_fault(struct pt_regs *regs, void *pc, void *sp);
+ extern void pax_report_insns(struct pt_regs *regs, void *pc, void *sp);
+ 
  #ifdef CONFIG_RSEQ
  
  /*
diff -rcNP og/include/linux/sysctl.h patched/include/linux/sysctl.h
*** og/include/linux/sysctl.h	2021-03-13 19:47:10.000000000 +0200
--- patched/include/linux/sysctl.h	2021-03-13 15:39:03.000000000 +0200
***************
*** 8,14 ****
   ****************************************************************
   **
   **  WARNING:
!  **  The values in this file are exported to user space via 
   **  the sysctl() binary interface.  Do *NOT* change the
   **  numbering of any existing values here, and do not change
   **  any numbers within any one set of values.  If you have to
--- 8,14 ----
   ****************************************************************
   **
   **  WARNING:
!  **  The values in this file are exported to user space via
   **  the sysctl() binary interface.  Do *NOT* change the
   **  numbering of any existing values here, and do not change
   **  any numbers within any one set of values.  If you have to
***************
*** 51,56 ****
--- 51,58 ----
  			 void __user *, size_t *, loff_t *);
  extern int proc_dointvec(struct ctl_table *, int,
  			 void __user *, size_t *, loff_t *);
+ int proc_dointvec_secure(struct ctl_table *, int,
+                     		void __user *, size_t *, loff_t *);
  extern int proc_douintvec(struct ctl_table *, int,
  			 void __user *, size_t *, loff_t *);
  extern int proc_dointvec_minmax(struct ctl_table *, int,
***************
*** 78,84 ****
  
  /*
   * Register a set of sysctl names by calling register_sysctl_table
!  * with an initialised array of struct ctl_table's.  An entry with 
   * NULL procname terminates the table.  table->de will be
   * set up by the registration and need not be initialised in advance.
   *
--- 80,86 ----
  
  /*
   * Register a set of sysctl names by calling register_sysctl_table
!  * with an initialised array of struct ctl_table's.  An entry with
   * NULL procname terminates the table.  table->de will be
   * set up by the registration and need not be initialised in advance.
   *
***************
*** 96,102 ****
   * the sysctl table.  The data and maxlen fields of the ctl_table
   * struct enable minimal validation of the values being written to be
   * performed, and the mode field allows minimal authentication.
!  * 
   * There must be a proc_handler routine for any terminal nodes
   * mirrored under /proc/sys (non-terminals are handled by a built-in
   * directory handler).  Several default handlers are available to
--- 98,104 ----
   * the sysctl table.  The data and maxlen fields of the ctl_table
   * struct enable minimal validation of the values being written to be
   * performed, and the mode field allows minimal authentication.
!  *
   * There must be a proc_handler routine for any terminal nodes
   * mirrored under /proc/sys (non-terminals are handled by a built-in
   * directory handler).  Several default handlers are available to
***************
*** 122,128 ****
  	struct ctl_table_poll name = __CTL_TABLE_POLL_INITIALIZER(name)
  
  /* A sysctl table is an array of struct ctl_table: */
! struct ctl_table 
  {
  	const char *procname;		/* Text ID for /proc/sys, or zero */
  	void *data;
--- 124,130 ----
  	struct ctl_table_poll name = __CTL_TABLE_POLL_INITIALIZER(name)
  
  /* A sysctl table is an array of struct ctl_table: */
! struct ctl_table
  {
  	const char *procname;		/* Text ID for /proc/sys, or zero */
  	void *data;
diff -rcNP og/include/linux/uidgid.h patched/include/linux/uidgid.h
*** og/include/linux/uidgid.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/uidgid.h	2021-03-13 15:39:50.000000000 +0200
***************
*** 188,191 ****
--- 188,197 ----
  
  #endif /* CONFIG_USER_NS */
  
+ #define GR_GLOBAL_UID(x) from_kuid_munged(&init_user_ns, (x))
+ #define GR_GLOBAL_GID(x) from_kgid_munged(&init_user_ns, (x))
+ #define gr_is_global_root(x) uid_eq((x), GLOBAL_ROOT_UID)
+ #define gr_is_global_nonroot(x) (!uid_eq((x), GLOBAL_ROOT_UID))
+ #define gr_is_global_nonroot_gid(x) (!gid_eq((x), GLOBAL_ROOT_GID))
+ 
  #endif /* _LINUX_UIDGID_H */
diff -rcNP og/include/linux/xattr.h patched/include/linux/xattr.h
*** og/include/linux/xattr.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/linux/xattr.h	2021-03-13 15:40:28.000000000 +0200
***************
*** 46,51 ****
--- 46,54 ----
  	size_t value_len;
  };
  
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ ssize_t pax_getxattr(struct dentry *, void *, size_t);
+ #endif
  ssize_t __vfs_getxattr(struct dentry *, struct inode *, const char *, void *, size_t);
  ssize_t vfs_getxattr(struct dentry *, const char *, void *, size_t);
  ssize_t vfs_listxattr(struct dentry *d, char *list, size_t size);
diff -rcNP og/include/uapi/linux/elf.h patched/include/uapi/linux/elf.h
*** og/include/uapi/linux/elf.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/uapi/linux/elf.h	2021-03-13 15:44:26.000000000 +0200
***************
*** 38,44 ****
--- 38,52 ----
  #define PT_GNU_EH_FRAME		0x6474e550
  
  #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
+ #define PT_GNU_RELRO	(PT_LOOS + 0x474e552)
  
+ #define PT_PAX_FLAGS	(PT_LOOS + 0x5041580)
+ 
+ #define EF_PAX_PAGEEXEC		1	/* Paging based non-executable pages */
+ #define EF_PAX_EMUTRAMP		2	/* Emulate trampolines */
+ #define EF_PAX_MPROTECT		4	/* Restrict mprotect() */
+ #define EF_PAX_RANDMMAP		8	/* Randomize mmap() base */
+ #define EF_PAX_SEGMEXEC		32	/* Segmentation based non-executable pages */
  /*
   * Extended Numbering
   *
***************
*** 95,100 ****
--- 103,110 ----
  #define DT_DEBUG	21
  #define DT_TEXTREL	22
  #define DT_JMPREL	23
+ #define DT_FLAGS	30
+   #define DF_TEXTREL  0x00000004
  #define DT_ENCODING	32
  #define OLD_DT_LOOS	0x60000000
  #define DT_LOOS		0x6000000d
***************
*** 241,246 ****
--- 251,267 ----
  #define PF_W		0x2
  #define PF_X		0x1
  
+ #define PF_PAGEEXEC	(1U << 4)	/* Enable  PAGEEXEC */
+ #define PF_NOPAGEEXEC	(1U << 5)	/* Disable PAGEEXEC */
+ #define PF_SEGMEXEC	(1U << 6)	/* Enable  SEGMEXEC */
+ #define PF_NOSEGMEXEC	(1U << 7)	/* Disable SEGMEXEC */
+ #define PF_MPROTECT	(1U << 8)	/* Enable  MPROTECT */
+ #define PF_NOMPROTECT	(1U << 9)	/* Disable MPROTECT */
+ #define PF_EMUTRAMP	(1U << 12)	/* Enable  EMUTRAMP */
+ #define PF_NOEMUTRAMP	(1U << 13)	/* Disable EMUTRAMP */
+ #define PF_RANDMMAP	(1U << 14)	/* Enable  RANDMMAP */
+ #define PF_NORANDMMAP	(1U << 15)	/* Disable RANDMMAP */
+ 
  typedef struct elf32_phdr{
    Elf32_Word	p_type;
    Elf32_Off	p_offset;
***************
*** 299,305 ****
  #define SHN_ABS		0xfff1
  #define SHN_COMMON	0xfff2
  #define SHN_HIRESERVE	0xffff
!  
  typedef struct elf32_shdr {
    Elf32_Word	sh_name;
    Elf32_Word	sh_type;
--- 320,326 ----
  #define SHN_ABS		0xfff1
  #define SHN_COMMON	0xfff2
  #define SHN_HIRESERVE	0xffff
! 
  typedef struct elf32_shdr {
    Elf32_Word	sh_name;
    Elf32_Word	sh_type;
***************
*** 336,341 ****
--- 357,364 ----
  #define	EI_OSABI	7
  #define	EI_PAD		8
  
+ #define	EI_PAX		14
+ 
  #define	ELFMAG0		0x7f		/* EI_MAG */
  #define	ELFMAG1		'E'
  #define	ELFMAG2		'L'
diff -rcNP og/include/uapi/linux/xattr.h patched/include/uapi/linux/xattr.h
*** og/include/uapi/linux/xattr.h	2021-03-11 15:06:51.000000000 +0200
--- patched/include/uapi/linux/xattr.h	2021-03-13 15:45:19.000000000 +0200
***************
*** 77,81 ****
--- 77,86 ----
  #define XATTR_POSIX_ACL_DEFAULT  "posix_acl_default"
  #define XATTR_NAME_POSIX_ACL_DEFAULT XATTR_SYSTEM_PREFIX XATTR_POSIX_ACL_DEFAULT
  
+ /* User namespace */
+ #define XATTR_PAX_PREFIX "pax."
+ #define XATTR_PAX_FLAGS_SUFFIX "flags"
+ #define XATTR_NAME_USER_PAX_FLAGS XATTR_USER_PREFIX XATTR_PAX_PREFIX XATTR_PAX_FLAGS_SUFFIX
+ #define XATTR_NAME_PAX_FLAGS XATTR_PAX_PREFIX XATTR_PAX_FLAGS_SUFFIX
  
  #endif /* _UAPI_LINUX_XATTR_H */
diff -rcNP og/init/main.c patched/init/main.c
*** og/init/main.c	2021-03-11 15:06:51.000000000 +0200
--- patched/init/main.c	2021-03-13 15:47:01.000000000 +0200
***************
*** 109,114 ****
--- 109,116 ----
  extern void init_IRQ(void);
  extern void radix_tree_init(void);
  
+ extern void minisec_init(void);
+ 
  /*
   * Debug helper: via this flag we know that we are in 'early bootup code'
   * where only the boot processor is running with IRQ disabled.  This means
***************
*** 170,175 ****
--- 172,208 ----
  
  __setup("reset_devices", set_reset_devices);
  
+ #ifdef CONFIG_MINISEC_PROC_USERGROUP
+ kgid_t grsec_proc_gid = KGIDT_INIT(CONFIG_MINISEC_PROC_GID);
+ static int __init setup_grsec_proc_gid(char *str)
+ {
+ 	grsec_proc_gid = KGIDT_INIT(simple_strtol(str, NULL, 0));
+ 	return 1;
+ }
+ __setup("grsec_proc_gid=", setup_grsec_proc_gid);
+ #endif
+ #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
+ int grsec_enable_sysfs_restrict = 1;
+ static int __init setup_grsec_sysfs_restrict(char *str)
+ {
+ 	if (!simple_strtol(str, NULL, 0))
+ 		grsec_enable_sysfs_restrict = 0;
+ 	return 1;
+ }
+ __setup("grsec_sysfs_restrict", setup_grsec_sysfs_restrict);
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ int pax_softmode;
+ 
+ static int __init setup_pax_softmode(char *str)
+ {
+ 	get_option(&str, &pax_softmode);
+ 	return 1;
+ }
+ __setup("pax_softmode=", setup_pax_softmode);
+ #endif
+ 
  static const char *argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
  const char *envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
  static const char *panic_later, *panic_param;
***************
*** 1214,1219 ****
--- 1247,1254 ----
  		prepare_namespace();
  	}
  
+ 	minisec_init();
+ 
  	/*
  	 * Ok, we have completed the initial bootup, and
  	 * we're essentially up and running. Get rid of the
diff -rcNP og/ipc/shm.c patched/ipc/shm.c
*** og/ipc/shm.c	2021-03-11 15:06:51.000000000 +0200
--- patched/ipc/shm.c	2021-03-13 15:47:56.000000000 +0200
***************
*** 1468,1473 ****
--- 1468,1478 ----
  		f_flags = O_RDWR;
  	}
  	if (shmflg & SHM_EXEC) {
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 		if (current->mm->pax_flags & MF_PAX_MPROTECT)
+ 			goto out;
+ #endif
+ 
  		prot |= PROT_EXEC;
  		acc_mode |= S_IXUGO;
  	}
diff -rcNP og/ipc/util.c patched/ipc/util.c
*** og/ipc/util.c	2021-03-13 19:47:21.000000000 +0200
--- patched/ipc/util.c	2021-03-13 15:50:01.000000000 +0200
***************
*** 78,83 ****
--- 78,85 ----
  
  extern int ipc_permitted(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, int requested_mode, int granted_mode);
  
+ extern int gr_ipc_permitted(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, int requested_mode, int granted_mode);
+ 
  /**
   * ipc_init - initialise ipc subsystem
   *
***************
*** 535,540 ****
--- 537,545 ----
  	if (!ipc_permitted(ns, ipcp, requested_mode, granted_mode))
  		return -1;
  
+ 	if (!gr_ipc_permitted(ns, ipcp, requested_mode, granted_mode))
+ 		return -1;
+ 
  	/* is there some bit set in requested_mode but not in granted_mode? */
  	if ((requested_mode & ~granted_mode & 0007) &&
  	    !ns_capable(ns->user_ns, CAP_IPC_OWNER))
diff -rcNP og/kernel/configs.c patched/kernel/configs.c
*** og/kernel/configs.c	2021-03-11 15:06:51.000000000 +0200
--- patched/kernel/configs.c	2021-03-13 15:51:10.000000000 +0200
***************
*** 58,65 ****
--- 58,75 ----
  	struct proc_dir_entry *entry;
  
  	/* create the current config file */
+ #if defined(CONFIG_MINISEC_PROC_ADD) || defined(CONFIG_MINISEC_HIDESYM)
+ #if defined(CONFIG_MINISEC_PROC_USER) || defined(CONFIG_MINISEC_HIDESYM)
+ 	entry = proc_create("config.gz", S_IFREG | S_IRUSR, NULL,
+ 			    &ikconfig_file_ops);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	entry = proc_create("config.gz", S_IFREG | S_IRUSR | S_IRGRP, NULL,
+ 			    &ikconfig_file_ops);
+ #endif
+ #else
  	entry = proc_create("config.gz", S_IFREG | S_IRUGO, NULL,
  			    &ikconfig_file_ops);
+ #endif
  	if (!entry)
  		return -ENOMEM;
  
diff -rcNP og/kernel/fork.c patched/kernel/fork.c
*** og/kernel/fork.c	2021-03-13 19:47:10.000000000 +0200
--- patched/kernel/fork.c	2021-03-13 15:52:03.000000000 +0200
***************
*** 914,920 ****
  	set_task_stack_end_magic(tsk);
  
  #ifdef CONFIG_STACKPROTECTOR
! 	tsk->stack_canary = get_random_canary();
  #endif
  	if (orig->cpus_ptr == &orig->cpus_mask)
  		tsk->cpus_ptr = &tsk->cpus_mask;
--- 914,920 ----
  	set_task_stack_end_magic(tsk);
  
  #ifdef CONFIG_STACKPROTECTOR
! 	tsk->stack_canary = pax_get_random_long();
  #endif
  	if (orig->cpus_ptr == &orig->cpus_mask)
  		tsk->cpus_ptr = &tsk->cpus_mask;
diff -rcNP og/kernel/module.c patched/kernel/module.c
*** og/kernel/module.c	2021-03-11 15:06:51.000000000 +0200
--- patched/kernel/module.c	2021-03-13 15:53:27.000000000 +0200
***************
*** 4437,4443 ****
--- 4437,4453 ----
  
  static int __init proc_modules_init(void)
  {
+ #ifndef CONFIG_MINISEC_HIDESYM
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	proc_create("modules", S_IRUSR, NULL, &modules_proc_ops);
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	proc_create("modules", S_IRUSR | S_IRGRP, NULL, &modules_proc_ops);
+ #else
  	proc_create("modules", 0, NULL, &proc_modules_operations);
+ #endif
+ #else
+ 	proc_create("modules", S_IRUSR, NULL, &modules_proc_ops);
+ #endif
  	return 0;
  }
  module_init(proc_modules_init);
diff -rcNP og/kernel/pid.c patched/kernel/pid.c
*** og/kernel/pid.c	2021-03-11 15:06:51.000000000 +0200
--- patched/kernel/pid.c	2021-03-13 15:54:09.000000000 +0200
***************
*** 355,360 ****
--- 355,367 ----
  	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
  }
  
+ struct task_struct *find_task_by_vpid_unrestricted(pid_t vnr)
+ {
+ 	RCU_LOCKDEP_WARN(!rcu_read_lock_held(),
+ 			 "find_task_by_pid_ns() needs rcu_read_lock() protection");
+ 	return pid_task(find_pid_ns(vnr, task_active_pid_ns(current)), PIDTYPE_PID);
+ }
+ 
  struct task_struct *find_get_task_by_vpid(pid_t nr)
  {
  	struct task_struct *task;
diff -rcNP og/kernel/sched/core.c patched/kernel/sched/core.c
*** og/kernel/sched/core.c	2021-03-11 15:06:51.000000000 +0200
--- patched/kernel/sched/core.c	2021-03-13 15:55:20.000000000 +0200
***************
*** 11,16 ****
--- 11,17 ----
  #include <linux/nospec.h>
  
  #include <linux/kcov.h>
+ #include <linux/minisec.h>
  
  #include <asm/switch_to.h>
  #include <asm/tlb.h>
***************
*** 4671,4677 ****
  	nice = task_nice(current) + increment;
  
  	nice = clamp_val(nice, MIN_NICE, MAX_NICE);
! 	if (increment < 0 && !can_nice(current, nice))
  		return -EPERM;
  
  	retval = security_task_setnice(current, nice);
--- 4672,4678 ----
  	nice = task_nice(current) + increment;
  
  	nice = clamp_val(nice, MIN_NICE, MAX_NICE);
! 	if ((increment < 0 && !can_nice(current, nice)) || gr_handle_chroot_nice())
  		return -EPERM;
  
  	retval = security_task_setnice(current, nice);
diff -rcNP og/kernel/sched/debug.c patched/kernel/sched/debug.c
*** og/kernel/sched/debug.c	2021-03-11 15:06:51.000000000 +0200
--- patched/kernel/sched/debug.c	2021-03-13 15:56:18.000000000 +0200
***************
*** 176,183 ****
--- 176,188 ----
  	debugfs_create_file("sched_features", 0644, NULL, NULL,
  			&sched_feat_fops);
  
+ #ifdef CONFIG_MINISEC_PROC_ADD
+ 	debugfs_create_bool("sched_debug", 0400, NULL,
+ 			&sched_debug_enabled);
+ #else
  	debugfs_create_bool("sched_debug", 0644, NULL,
  			&sched_debug_enabled);
+ #endif
  
  	return 0;
  }
diff -rcNP og/kernel/sys.c patched/kernel/sys.c
*** og/kernel/sys.c	2021-03-11 15:06:51.000000000 +0200
--- patched/kernel/sys.c	2021-03-13 15:57:49.000000000 +0200
***************
*** 62,67 ****
--- 62,68 ----
  #include <linux/cred.h>
  
  #include <linux/nospec.h>
+ #include <linux/minisec.h>
  
  #include <linux/kmsg_dump.h>
  /* Move somewhere else to avoid recompiling? */
***************
*** 181,186 ****
--- 182,193 ----
  		error = -EACCES;
  		goto out;
  	}
+ 
+ 	if (gr_handle_chroot_setpriority(p, niceval)) {
+ 		error = -EACCES;
+ 		goto out;
+ 	}
+ 
  	no_nice = security_task_setnice(p, niceval);
  	if (no_nice) {
  		error = no_nice;
diff -rcNP og/kernel/sysctl.c patched/kernel/sysctl.c
*** og/kernel/sysctl.c	2021-03-13 19:47:21.000000000 +0200
--- patched/kernel/sysctl.c	2021-03-13 19:12:17.000000000 +0200
***************
*** 70,75 ****
--- 70,79 ----
  #include <linux/userfaultfd_k.h>
  #include <linux/ipc.h>
  
+ #ifdef CONFIG_MINISEC
+ #include <linux/minisec.h>
+ #endif
+ 
  #include "../lib/kstrtox.h"
  
  #include <linux/uaccess.h>
***************
*** 305,310 ****
--- 309,330 ----
  	{ }
  };
  
+ extern struct ctl_table grsecurity_table[];
+ 
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ static struct ctl_table pax_table[] = {
+ 	{
+ 		.procname	= "softmode",
+ 		.data		= &pax_softmode,
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec,
+ 	},
+ 
+ 	{ }
+ };
+ #endif
+ 
  #ifdef CONFIG_SCHED_DEBUG
  static int min_sched_granularity_ns __read_only = 100000;		/* 100 usecs */
  static int max_sched_granularity_ns __read_only = NSEC_PER_SEC;	/* 1 second */
***************
*** 322,327 ****
--- 342,375 ----
  #endif
  
  static struct ctl_table kern_table[] = {
+ 	#ifdef CONFIG_MINISEC_SOFTMODE
+ 	{
+ 		.procname	= "pax",
+ 		.mode		= 0500,
+ 		.child		= pax_table,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_SYSCTL
+ 	{
+ 		.procname	= "grsecurity",
+ 		.mode		= 0500,
+ 		.child		= grsecurity_table,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_SOFTMODE
+ 	{
+ 		.procname	= "pax",
+ 		.mode		= 0500,
+ 		.child		= pax_table,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_SYSCTL
+ 	{
+ 		.procname	= "grsecurity",
+ 		.mode		= 0500,
+ 		.child		= grsecurity_table,
+ 	},
+ #endif
  	{
  		.procname	= "sched_child_runs_first",
  		.data		= &sysctl_sched_child_runs_first,
***************
*** 1386,1392 ****
  		.proc_handler	= overcommit_kbytes_handler,
  	},
  	{
! 		.procname	= "page-cluster", 
  		.data		= &page_cluster,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
--- 1434,1440 ----
  		.proc_handler	= overcommit_kbytes_handler,
  	},
  	{
! 		.procname	= "page-cluster",
  		.data		= &page_cluster,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
***************
*** 1904,1910 ****
  		.mode		= 0555,
  		.child		= inotify_table,
  	},
! #endif	
  #ifdef CONFIG_EPOLL
  	{
  		.procname	= "epoll",
--- 1952,1958 ----
  		.mode		= 0555,
  		.child		= inotify_table,
  	},
! #endif
  #ifdef CONFIG_EPOLL
  	{
  		.procname	= "epoll",
***************
*** 2385,2396 ****
  	int *i, vleft, first = 1, err = 0;
  	size_t left;
  	char *kbuf = NULL, *p;
! 	
  	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
  		*lenp = 0;
  		return 0;
  	}
! 	
  	i = (int *) tbl_data;
  	vleft = table->maxlen / sizeof(*i);
  	left = *lenp;
--- 2433,2444 ----
  	int *i, vleft, first = 1, err = 0;
  	size_t left;
  	char *kbuf = NULL, *p;
! 
  	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
  		*lenp = 0;
  		return 0;
  	}
! 
  	i = (int *) tbl_data;
  	vleft = table->maxlen / sizeof(*i);
  	left = *lenp;
***************
*** 2616,2622 ****
   * @ppos: file position
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string. 
   *
   * Returns 0 on success.
   */
--- 2664,2670 ----
   * @ppos: file position
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string.
   *
   * Returns 0 on success.
   */
***************
*** 2646,2651 ****
--- 2694,2775 ----
  				 do_proc_douintvec_conv, NULL);
  }
  
+ static int do_proc_dointvec_conv_secure(bool *negp, unsigned long *lvalp,
+ 				 int *valp,
+ 				 int write, void *data)
+ {
+ 	if (write) {
+ 		if (*negp) {
+ 			if (*lvalp > (unsigned long) INT_MAX + 1)
+ 				return -EINVAL;
+ //			pax_open_kernel(); for PAX_KERNEXEC ;)
+ 			*valp = -*lvalp;
+ //			pax_close_kernel();
+ 		} else {
+ 			if (*lvalp > (unsigned long) INT_MAX)
+ 				return -EINVAL;
+ //			pax_open_kernel(); for PAX_KERNEXEC ;)
+ 			*valp = *lvalp;
+ //			pax_close_kernel();
+ 		}
+ 	} else {
+ 		int val = *valp;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			*lvalp = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			*lvalp = (unsigned long)val;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ int proc_dointvec_secure(struct ctl_table *table, int write,
+ 		     void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_dointvec(table,write,buffer,lenp,ppos,
+ 				do_proc_dointvec_conv_secure,NULL);
+ }
+ 
+ static int do_proc_dointvec_conv_secure(bool *negp, unsigned long *lvalp,
+ 				 int *valp,
+ 				 int write, void *data)
+ {
+ 	if (write) {
+ 		if (*negp) {
+ 			if (*lvalp > (unsigned long) INT_MAX + 1)
+ 				return -EINVAL;
+ //			pax_open_kernel(); for PAX_KERNEXEC ;)
+ 			*valp = -*lvalp;
+ //			pax_close_kernel();
+ 		} else {
+ 			if (*lvalp > (unsigned long) INT_MAX)
+ 				return -EINVAL;
+ //			pax_open_kernel(); for PAX_KERNEXEC ;)
+ 			*valp = *lvalp;
+ //			pax_close_kernel();
+ 		}
+ 	} else {
+ 		int val = *valp;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			*lvalp = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			*lvalp = (unsigned long)val;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ int proc_dointvec_secure(struct ctl_table *table, int write,
+ 		     void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_dointvec(table,write,buffer,lenp,ppos,
+ 				do_proc_dointvec_conv_secure,NULL);
+ }
+ 
  /*
   * Taint values can only be increased
   * This means we can safely use a temporary.
***************
*** 3129,3135 ****
   * @ppos: file position
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string. 
   * The values read are assumed to be in seconds, and are converted into
   * jiffies.
   *
--- 3253,3259 ----
   * @ppos: file position
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string.
   * The values read are assumed to be in seconds, and are converted into
   * jiffies.
   *
***************
*** 3151,3158 ****
   * @ppos: pointer to the file position
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string. 
!  * The values read are assumed to be in 1/USER_HZ seconds, and 
   * are converted into jiffies.
   *
   * Returns 0 on success.
--- 3275,3282 ----
   * @ppos: pointer to the file position
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string.
!  * The values read are assumed to be in 1/USER_HZ seconds, and
   * are converted into jiffies.
   *
   * Returns 0 on success.
***************
*** 3174,3181 ****
   * @ppos: the current position in the file
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string. 
!  * The values read are assumed to be in 1/1000 seconds, and 
   * are converted into jiffies.
   *
   * Returns 0 on success.
--- 3298,3305 ----
   * @ppos: the current position in the file
   *
   * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
!  * values from/to the user buffer, treated as an ASCII string.
!  * The values read are assumed to be in 1/1000 seconds, and
   * are converted into jiffies.
   *
   * Returns 0 on success.
diff -rcNP og/mm/mmap.c patched/mm/mmap.c
*** og/mm/mmap.c	2021-03-13 19:47:10.000000000 +0200
--- patched/mm/mmap.c	2021-03-13 16:06:55.000000000 +0200
***************
*** 1464,1469 ****
--- 1464,1493 ----
  	vm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |
  			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
  
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (mm->pax_flags & MF_PAX_MPROTECT) {
+ 
+ #ifndef CONFIG_MINISEC_MPROTECT_COMPAT
+ 		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC)) {
+ 			return -EPERM;
+ 		}
+ 
+ 		if (!(vm_flags & VM_EXEC))
+ 			vm_flags &= ~VM_MAYEXEC;
+ #else
+ 		if ((vm_flags & (VM_WRITE | VM_EXEC)) != VM_EXEC)
+ 			vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+ #endif
+ 		else
+ 			vm_flags &= ~VM_MAYWRITE;
+ 	}
+ #endif
+ 
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(CONFIG_X86_32)
+ 	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && file)
+ 		vm_flags &= ~VM_PAGEEXEC;
+ #endif
+ 
  	if (flags & MAP_LOCKED)
  		if (!can_do_mlock())
  			return -EPERM;
***************
*** 1804,1809 ****
--- 1828,1840 ----
  		if (error)
  			goto unmap_and_free_vma;
  
+ #if defined(CONFIG_MINISEC_PAGEEXEC) && defined(CONFIG_X86_32)
+ 		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_SPECIAL)) {
+ 			vma->vm_flags |= VM_PAGEEXEC;
+ 			vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+ 		}
+ #endif
+ 
  		/* Can addr have changed??
  		 *
  		 * Answer: Yes, several device drivers can do it in their
***************
*** 3023,3028 ****
--- 3054,3071 ----
  		return -EINVAL;
  	flags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;
  
+ #if defined(CONFIG_MINISEC_PAGEEXEC)
+ 	if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+ 		flags &= ~VM_EXEC;
+ 
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 		if (mm->pax_flags & MF_PAX_MPROTECT)
+ 			flags &= ~VM_MAYEXEC;
+ #endif
+ 
+ 	}
+ #endif
+ 
  	error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);
  	if (offset_in_page(error))
  		return error;
***************
*** 3431,3436 ****
--- 3474,3496 ----
  	vma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;
  	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
  
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (mm->pax_flags & MF_PAX_MPROTECT) {
+ #ifndef CONFIG_MINISEC_MPROTECT_COMPAT
+ 		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC))
+ 			return ERR_PTR(-EPERM);
+ 
+ 		if (!(vm_flags & VM_EXEC))
+ 			vm_flags &= ~VM_MAYEXEC;
+ #else
+ 		if ((vm_flags & (VM_WRITE | VM_EXEC)) != VM_EXEC)
+ 			vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+ #endif
+ 		else
+ 			vm_flags &= ~VM_MAYWRITE;
+ 	}
+ #endif
+ 
  	vma->vm_ops = ops;
  	vma->vm_private_data = priv;
  
diff -rcNP og/mm/mprotect.c patched/mm/mprotect.c
*** og/mm/mprotect.c	2021-03-11 15:06:51.000000000 +0200
--- patched/mm/mprotect.c	2021-03-13 16:08:46.000000000 +0200
***************
*** 26,31 ****
--- 26,35 ----
  #include <linux/perf_event.h>
  #include <linux/pkeys.h>
  #include <linux/ksm.h>
+ #ifdef CONFIG_MINISEC_MPROTECT
+ #include <linux/elf.h>
+ #include <linux/binfmts.h>
+ #endif
  #include <linux/uaccess.h>
  #include <linux/mm_inline.h>
  #include <asm/pgtable.h>
***************
*** 455,460 ****
--- 459,468 ----
  	 * held in write mode.
  	 */
  	vma->vm_flags = newflags;
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (mm->binfmt && mm->binfmt->handle_mprotect)
+ 		mm->binfmt->handle_mprotect(vma, newflags);
+ #endif
  	dirty_accountable = vma_wants_writenotify(vma, vma->vm_page_prot);
  	vma_set_page_prot(vma);
  
***************
*** 548,553 ****
--- 556,566 ----
  	if (start > vma->vm_start)
  		prev = vma;
  
+ #ifdef CONFIG_MINISEC_MPROTECT
+ 	if (current->mm->binfmt && current->mm->binfmt->handle_mprotect)
+ 		current->mm->binfmt->handle_mprotect(vma, calc_vm_prot_bits(prot, 0));
+ #endif
+ 
  	for (nstart = start ; ; ) {
  		unsigned long mask_off_old_flags;
  		unsigned long newflags;
diff -rcNP og/mm/shmem.c patched/mm/shmem.c
*** og/mm/shmem.c	2021-03-11 15:06:51.000000000 +0200
--- patched/mm/shmem.c	2021-03-13 16:11:20.000000000 +0200
***************
*** 3248,3253 ****
--- 3248,3271 ----
  	return simple_xattr_set(&info->xattrs, name, value, size, flags);
  }
  
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ static int shmem_user_xattr_handler_set(const struct xattr_handler *handler,
+ 					struct dentry *dentry, struct inode *inode,
+ 					const char *name, const void *value,
+ 					size_t size, int flags)
+ {
+ 	struct shmem_inode_info *info = SHMEM_I(inode);
+ 
+ 	if (strcmp(name, XATTR_NAME_PAX_FLAGS))
+ 		return -EOPNOTSUPP;
+ 	if (size > 8)
+ 		return -EINVAL;
+ 
+ 	name = xattr_full_name(handler, name);
+ 	return simple_xattr_set(&info->xattrs, name, value, size, flags, NULL);
+ }
+ #endif
+ 
  static const struct xattr_handler shmem_security_xattr_handler = {
  	.prefix = XATTR_SECURITY_PREFIX,
  	.get = shmem_xattr_handler_get,
***************
*** 3260,3265 ****
--- 3278,3291 ----
  	.set = shmem_xattr_handler_set,
  };
  
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ static const struct xattr_handler shmem_user_xattr_handler = {
+ 	.prefix = XATTR_USER_PREFIX,
+ 	.get = shmem_xattr_handler_get,
+ 	.set = shmem_user_xattr_handler_set,
+ };
+ #endif
+ 
  static const struct xattr_handler *shmem_xattr_handlers[] = {
  #ifdef CONFIG_TMPFS_POSIX_ACL
  	&posix_acl_access_xattr_handler,
***************
*** 3267,3272 ****
--- 3293,3301 ----
  #endif
  	&shmem_security_xattr_handler,
  	&shmem_trusted_xattr_handler,
+ #ifdef CONFIG_MINISEC_XATTR_PAX_FLAGS
+ 	&shmem_user_xattr_handler,
+ #endif
  	NULL
  };
  
diff -rcNP og/mm/slab_common.c patched/mm/slab_common.c
*** og/mm/slab_common.c	2021-03-13 19:47:10.000000000 +0200
--- patched/mm/slab_common.c	2021-03-13 16:12:44.000000000 +0200
***************
*** 598,604 ****
  	rcu_barrier();
  
  	list_for_each_entry_safe(s, s2, &to_destroy, list) {
! #ifdef SLAB_SUPPORTS_SYSFS
  		sysfs_slab_release(s);
  #else
  		slab_kmem_cache_release(s);
--- 598,604 ----
  	rcu_barrier();
  
  	list_for_each_entry_safe(s, s2, &to_destroy, list) {
! #if defined(SLAB_SUPPORTS_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  		sysfs_slab_release(s);
  #else
  		slab_kmem_cache_release(s);
***************
*** 618,630 ****
  	list_del(&s->list);
  
  	if (s->flags & SLAB_TYPESAFE_BY_RCU) {
! #ifdef SLAB_SUPPORTS_SYSFS
  		sysfs_slab_unlink(s);
  #endif
  		list_add_tail(&s->list, &slab_caches_to_rcu_destroy);
  		schedule_work(&slab_caches_to_rcu_destroy_work);
  	} else {
! #ifdef SLAB_SUPPORTS_SYSFS
  		sysfs_slab_unlink(s);
  		sysfs_slab_release(s);
  #else
--- 618,630 ----
  	list_del(&s->list);
  
  	if (s->flags & SLAB_TYPESAFE_BY_RCU) {
! #if defined(SLAB_SUPPORTS_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  		sysfs_slab_unlink(s);
  #endif
  		list_add_tail(&s->list, &slab_caches_to_rcu_destroy);
  		schedule_work(&slab_caches_to_rcu_destroy_work);
  	} else {
! #if defined(SLAB_SUPPORTS_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  		sysfs_slab_unlink(s);
  		sysfs_slab_release(s);
  #else
diff -rcNP og/mm/slub.c patched/mm/slub.c
*** og/mm/slub.c	2021-03-13 19:47:10.000000000 +0200
--- patched/mm/slub.c	2021-03-13 19:18:52.000000000 +0200
***************
*** 219,225 ****
  
  enum track_item { TRACK_ALLOC, TRACK_FREE };
  
! #ifdef CONFIG_SYSFS
  static int sysfs_slab_add(struct kmem_cache *);
  static int sysfs_slab_alias(struct kmem_cache *, const char *);
  static void memcg_propagate_slab_attrs(struct kmem_cache *s);
--- 219,225 ----
  
  enum track_item { TRACK_ALLOC, TRACK_FREE };
  
! #if defined(CONFIG_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  static int sysfs_slab_add(struct kmem_cache *);
  static int sysfs_slab_alias(struct kmem_cache *, const char *);
  static void memcg_propagate_slab_attrs(struct kmem_cache *s);
***************
*** 4934,4940 ****
  #endif
  #endif	/* SLUB_RESILIENCY_TEST */
  
! #ifdef CONFIG_SYSFS
  enum slab_stat_type {
  	SL_ALL,			/* All slabs */
  	SL_PARTIAL,		/* Only partially allocated slabs */
--- 4934,4940 ----
  #endif
  #endif	/* SLUB_RESILIENCY_TEST */
  
! #if defined(CONFIG_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  enum slab_stat_type {
  	SL_ALL,			/* All slabs */
  	SL_PARTIAL,		/* Only partially allocated slabs */
***************
*** 5903,5908 ****
--- 5903,5909 ----
  	kobject_put(&s->kobj);
  }
  
+ #if defined(CONFIG_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  static int sysfs_slab_add(struct kmem_cache *s)
  {
  	int err;
***************
*** 5982,5987 ****
--- 5983,5989 ----
  	kobject_get(&s->kobj);
  	schedule_work(&s->kobj_remove_work);
  }
+ #endif
  
  void sysfs_slab_unlink(struct kmem_cache *s)
  {
***************
*** 6007,6012 ****
--- 6009,6015 ----
  
  static struct saved_alias *alias_list;
  
+ #if defined(CONFIG_SYSFS) && !defined(CONFIG_MINISEC_PROC_ADD)
  static int sysfs_slab_alias(struct kmem_cache *s, const char *name)
  {
  	struct saved_alias *al;
***************
*** 6029,6034 ****
--- 6032,6038 ----
  	alias_list = al;
  	return 0;
  }
+ #endif
  
  static int __init slab_sysfs_init(void)
  {
diff -rcNP og/mm/util.c patched/mm/util.c
*** og/mm/util.c	2021-03-13 19:47:11.000000000 +0200
--- patched/mm/util.c	2021-03-13 19:19:41.000000000 +0200
***************
*** 308,313 ****
--- 308,318 ----
  {
  	unsigned long random_variable = 0;
  
+ #ifdef CONFIG_MINISEC_RANDUSTACK
+ 	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+ 		return stack_top - current->mm->delta_stack;
+ #endif
+ 
  	if (current->flags & PF_RANDOMIZE) {
  		random_variable = get_random_long();
  		random_variable &= STACK_RND_MASK;
diff -rcNP og/mm/vmstat.c patched/mm/vmstat.c
*** og/mm/vmstat.c	2021-03-11 15:06:51.000000000 +0200
--- patched/mm/vmstat.c	2021-03-13 19:23:02.000000000 +0200
***************
*** 28,33 ****
--- 28,34 ----
  #include <linux/mm_inline.h>
  #include <linux/page_ext.h>
  #include <linux/page_owner.h>
+ #include <linux/minisec.h>
  
  #include "internal.h"
  
***************
*** 1690,1695 ****
--- 1691,1707 ----
  		v[i] = global_zone_page_state(i);
  	v += NR_VM_ZONE_STAT_ITEMS;
  
+ #ifdef CONFIG_MINISEC_PROC_ADD
+ #if defined(CONFIG_MINISEC_PROC_USER) || defined(CONFIG_MINISEC_PROC_USERGROUP)
+         if (!uid_eq(current_uid(), GLOBAL_ROOT_UID)
+ #ifdef CONFIG_MINISEC_PROC_USERGROUP
+                 && !in_group_p(grsec_proc_gid)
+ #endif
+         )
+ 		return (unsigned long *)m->private + *pos;
+ #endif
+ #endif
+ 
  #ifdef CONFIG_NUMA
  	for (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)
  		v[i] = global_numa_state(i);
***************
*** 1988,1997 ****
  	start_shepherd_timer();
  #endif
  #ifdef CONFIG_PROC_FS
! 	proc_create_seq("buddyinfo", 0444, NULL, &fragmentation_op);
! 	proc_create_seq("pagetypeinfo", 0400, NULL, &pagetypeinfo_op);
! 	proc_create_seq("vmstat", 0444, NULL, &vmstat_op);
! 	proc_create_seq("zoneinfo", 0444, NULL, &zoneinfo_op);
  #endif
  }
  
--- 2000,2016 ----
  	start_shepherd_timer();
  #endif
  #ifdef CONFIG_PROC_FS
! {
! 	mode_t gr_mode = S_IRUGO;
! #ifdef CONFIG_MINISEC_PROC_ADD
! 	gr_mode = S_IRUSR;
! #endif
! 	proc_create_seq("buddyinfo", gr_mode, NULL, &fragmentation_op);
! 	proc_create_seq("pagetypeinfo", gr_mode, NULL, &pagetypeinfo_op);
! 	proc_create_seq("vmstat", gr_mode, NULL, &vmstat_op);
! 	proc_create_seq("zoneinfo", gr_mode, NULL, &zoneinfo_op);
! }
! 
  #endif
  }
  
diff -rcNP og/net/unix/af_unix.c patched/net/unix/af_unix.c
*** og/net/unix/af_unix.c	2021-03-11 15:06:51.000000000 +0200
--- patched/net/unix/af_unix.c	2021-03-13 19:24:40.000000000 +0200
***************
*** 113,118 ****
--- 113,119 ----
  #include <linux/security.h>
  #include <linux/freezer.h>
  #include <linux/file.h>
+ #include <linux/minisec.h>
  
  #include "scm.h"
  
***************
*** 954,959 ****
--- 955,967 ----
  		u = unix_find_socket_byname(net, sunname, len, type, hash);
  		if (u) {
  			struct dentry *dentry;
+ 
+ 			if (!gr_handle_chroot_unix(pid_vnr(u->sk_peer_pid))) {
+ 				err = -EPERM;
+ 				sock_put(u);
+ 				goto fail;
+ 			}
+ 
  			dentry = unix_sk(u)->path.dentry;
  			if (dentry)
  				touch_atime(&unix_sk(u)->path);
diff -rcNP og/security/Kconfig patched/security/Kconfig
*** og/security/Kconfig	2021-03-13 19:47:21.000000000 +0200
--- patched/security/Kconfig	2021-03-13 19:26:37.000000000 +0200
***************
*** 7,12 ****
--- 7,666 ----
  
  source "security/keys/Kconfig"
  
+ menu "miniSEC"
+ 
+ config MINISEC
+ 	bool "Enable various miniSEC features"
+ 	default n
+ 	depends on (ARM && (CPU_V6 || CPU_V6K || CPU_V7)) || X86
+ 	help
+ 	  **WARNING**: This project is a fork of grsecurity and PaX!
+ 	  For more information: https://grsecurity.net/
+ 
+ 	  This allows you to enable various miniSEC features.  miniSEC adds
+ 	  intrusion prevention mechanisms to the kernel that reduce
+ 	  the risks posed by exploitable memory corruption bugs.
+ 
+ config TASK_SIZE_MAX_SHIFT
+ 	int
+ 	depends on X86_64
+ 	default 47
+ 
+ menu "miniSEC Control"
+ 	depends on MINISEC
+ 
+ config MINISEC_SOFTMODE
+ 	bool 'Support soft mode'
+ 	help
+ 	  Enabling this option will allow you to run miniSEC in soft mode, that
+ 	  is, PaX features will not be enforced by default, only on executables
+ 	  marked explicitly.  You must also enable PT_PAX_FLAGS or XATTR_PAX_FLAGS
+ 	  support as they are the only way to mark executables for soft mode use.
+ 
+ 	  Soft mode can be activated by using the "pax_softmode=1" kernel command
+ 	  line option on boot.  Furthermore you can control various PaX features
+ 	  at runtime via the entries in /proc/sys/kernel/pax.
+ 
+ config MINISEC_EI_PAX
+ 	bool 'Use legacy ELF header marking'
+ 	default n
+ 	help
+ 	  Enabling this option will allow you to control miniSEC features on
+ 	  a per executable basis via the 'chpax' utility available at
+ 	  https://localhost/.  The control flags will be read from
+ 	  an otherwise reserved part of the ELF header. This marking has
+ 	  numerous drawbacks (no support for soft-mode, toolchain does not
+ 	  know about the non-standard use of the ELF header) therefore it
+ 	  has been deprecated in favour of PT_PAX_FLAGS and XATTR_PAX_FLAGS
+ 	  support.
+ 
+ 	  Note that if you enable PT_PAX_FLAGS or XATTR_PAX_FLAGS marking
+ 	  support as well, they will override the legacy EI_PAX marks.
+ 
+ 	  If you enable none of the marking options then all applications
+ 	  will run with miniSEC enabled on them by default.
+ 
+ config MINISEC_PT_PAX_FLAGS
+ 	bool 'Use ELF program header marking'
+ 	default n
+ 	help
+ 	  Enabling this option will allow you to control miniSEC features on
+ 	  a per executable basis via the 'paxctl' utility available at
+ 	  https://localhost/.  The control flags will be read from
+ 	  a PaX specific ELF program header (PT_PAX_FLAGS).
+ 
+ 	  Note that if you enable the legacy EI_PAX marking support as well,
+ 	  the EI_PAX marks will be overridden by the PT_PAX_FLAGS marks.
+ 
+ 	  If you enable both PT_PAX_FLAGS and XATTR_PAX_FLAGS support then you
+ 	  must make sure that the marks are the same if a binary has both marks.
+ 
+ 	  If you enable none of the marking options then all applications
+ 	  will run with miniSEC enabled on them by default.
+ 
+ config MINISEC_XATTR_PAX_FLAGS
+ 	bool 'Use filesystem extended attributes marking'
+ 	default n
+ 	select CIFS_XATTR if CIFS
+ 	select EXT2_FS_XATTR if EXT2_FS
+ 	select EXT3_FS_XATTR if EXT3_FS
+ 	select F2FS_FS_XATTR if F2FS_FS
+ 	select JFFS2_FS_XATTR if JFFS2_FS
+ 	select REISERFS_FS_XATTR if REISERFS_FS
+ 	select SQUASHFS_XATTR if SQUASHFS
+ 	select TMPFS_XATTR if TMPFS
+ 	help
+ 	  Enabling this option will allow you to control miniSEC features on
+ 	  a per executable basis via the 'setfattr' utility.  The control
+ 	  flags will be read from the user.pax.flags extended attribute of
+ 	  the file.  This marking has the benefit of supporting binary-only
+ 	  applications that self-check themselves (e.g., skype) and would
+ 	  not tolerate chpax/paxctl changes.  The main drawback is that
+ 	  extended attributes are not supported by some filesystems (e.g.,
+ 	  isofs, udf, vfat) so copying files through such filesystems will
+ 	  lose the extended attributes and these miniSEC markings.
+ 
+ 	  Note that if you enable the legacy EI_PAX marking support as well,
+ 	  the EI_PAX marks will be overridden by the XATTR_PAX_FLAGS marks.
+ 
+ 	  If you enable both PT_PAX_FLAGS and XATTR_PAX_FLAGS support then you
+ 	  must make sure that the marks are the same if a binary has both marks.
+ 
+ 	  If you enable none of the marking options then all applications
+ 	  will run with miniSEC enabled on them by default.
+ 
+ endmenu
+ 
+ menu "Non-executable pages"
+ 	depends on MINISEC
+ 
+ config MINISEC_NOEXEC
+ 	bool "Enforce non-executable pages"
+ 	default n
+ 	depends on (ARM && (CPU_V6 || CPU_V6K || CPU_V7)) || X86
+ 	help
+ 	  By design some architectures do not allow for protecting memory
+ 	  pages against execution or even if they do, Linux does not make
+ 	  use of this feature.  In practice this means that if a page is
+ 	  readable (such as the stack or heap) it is also executable.
+ 
+ 	  There is a well known exploit technique that makes use of this
+ 	  fact and a common programming mistake where an attacker can
+ 	  introduce code of his choice somewhere in the attacked program's
+ 	  memory (typically the stack or the heap) and then execute it.
+ 
+ 	  If the attacked program was running with different (typically
+ 	  higher) privileges than that of the attacker, then he can elevate
+ 	  his own privilege level (e.g. get a root shell, write to files for
+ 	  which he does not have write access to, etc).
+ 
+ 	  Enabling this option will let you choose from various features
+ 	  that prevent the injection and execution of 'foreign' code in
+ 	  a program.
+ 
+ 	  This will also break programs that rely on the old behaviour and
+ 	  expect that dynamically allocated memory via the malloc() family
+ 	  of functions is executable (which it is not).  Notable examples
+ 	  are the XFree86 4.x server, the java runtime and wine.
+ 
+ config MINISEC_PAGEEXEC
+ 	bool "Paging based non-executable pages"
+ 	default n
+ 	depends on MINISEC_NOEXEC && (!X86_32 || M586 || M586TSC || M586MMX || M686 || MPENTIUMII || MPENTIUMIII || MPENTIUMM || MCORE2 || MATOM || MPENTIUM4 || MPSC || MK7 || MK8 || MWINCHIPC6 || MWINCHIP2 || MWINCHIP3D || MVIAC3_2 || MVIAC7)
+ 	select ARCH_TRACK_EXEC_LIMIT if X86_32
+ 	select ARCH_NEEDS_NX if X86_64 || X86_PAE
+ 	help
+ 	  This implementation is based on the paging feature of the CPU.
+ 	  On i386 without hardware non-executable bit support there is a
+ 	  variable but usually low performance impact, however on Intel's
+ 	  P4 core based CPUs it is very high so you should not enable this
+ 	  for kernels meant to be used on such CPUs.
+ 
+ 	  On alpha, avr32, ia64, parisc, sparc, sparc64, x86_64 and i386
+ 	  with hardware non-executable bit support there is no performance
+ 	  impact, on ppc the impact is negligible.
+ 
+ 	  Note that several architectures require various emulations due to
+ 	  badly designed userland ABIs, this will cause a performance impact
+ 	  but will disappear as soon as userland is fixed. For example, ppc
+ 	  userland MUST have been built with secure-plt by a recent toolchain.
+ 
+ config MINISEC_EMUTRAMP
+ 	bool "Emulate trampolines"
+ 	default n
+ 	depends on MINISEC_PAGEEXEC && X86
+ 	help
+ 	  There are some programs and libraries that for one reason or
+ 	  another attempt to execute special small code snippets from
+ 	  non-executable memory pages.  Most notable examples are the
+ 	  signal handler return code generated by the kernel itself and
+ 	  the GCC trampolines.
+ 
+ 	  If you enabled CONFIG_MINISEC_PAGEEXEC then
+ 	  such programs will no longer work under your kernel.
+ 
+ 	  As a remedy you can say Y here and use the 'chpax' or 'paxctl'
+ 	  utilities to enable trampoline emulation for the affected programs
+ 	  yet still have the protection provided by the non-executable pages.
+ 
+ 	  Alternatively you can say N here and use the 'chpax' or 'paxctl'
+ 	  utilities to disable CONFIG_MINISEC_PAGEEXEC for the affected files.
+ 
+ 	  NOTE: enabling this feature *may* open up a loophole in the
+ 	  protection provided by non-executable pages that an attacker
+ 	  could abuse.  Therefore the best solution is to not have any
+ 	  files on your system that would require this option.  This can
+ 	  be achieved by not using libc5 (which relies on the kernel
+ 	  signal handler return code) and not using or rewriting programs
+ 	  that make use of the nested function implementation of GCC.
+ 	  Skilled users can just fix GCC itself so that it implements
+ 	  nested function calls in a way that does not interfere with miniSEC.
+ 
+ config MINISEC_MPROTECT
+ 	bool "Restrict mprotect()"
+ 	default n
+ 	depends on MINISEC_PAGEEXEC
+ 	help
+ 	  Enabling this option will prevent programs from
+ 	   - changing the executable status of memory pages that were
+ 	     not originally created as executable,
+ 	   - making read-only executable pages writable again,
+ 	   - creating executable pages from anonymous memory,
+ 	   - making read-only-after-relocations (RELRO) data pages writable again.
+ 
+ 	  You should say Y here to complete the protection provided by
+ 	  the enforcement of non-executable pages.
+ 
+ 	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+ 	  this feature on a per file basis.
+ 
+ config MINISEC_MPROTECT_COMPAT
+ 	bool "Use legacy/compat protection demoting (read help)"
+ 	depends on MINISEC_MPROTECT
+ 	default n
+ 	help
+ 	  The current implementation of MINISEC_MPROTECT denies RWX allocations/mprotects
+ 	  by sending the proper error code to the application.  For some older
+ 	  userland, this can cause problems with applications that assume such
+ 	  allocations will not be prevented by miniSEC or SELinux and other access
+ 	  control systems and have no fallback mechanisms.  For modern distros,
+ 	  this option should generally be set to 'N'.
+ 
+ endmenu
+ 
+ menu "Address Space Layout Randomization"
+ 	depends on MINISEC
+ 
+ config MINISEC_ASLR
+ 	bool "Address Space Layout Randomization"
+ 	default n
+ 	help
+ 	  Many if not most exploit techniques rely on the knowledge of
+ 	  certain addresses in the attacked program.  The following options
+ 	  will allow the kernel to apply a certain amount of randomization
+ 	  to specific parts of the program thereby forcing an attacker to
+ 	  guess them in most cases.  Any failed guess will most likely crash
+ 	  the attacked program which allows the kernel to detect such attempts
+ 	  and react on them.  miniSEC itself provides no reaction mechanisms,
+ 	  instead it is strongly encouraged that you make use of miniSEC's
+ 	  (https://localhost/) built-in crash detection features or
+ 	  develop one yourself.
+ 
+ 	  By saying Y here you can choose to randomize the following areas:
+ 	   - top of the task's kernel stack
+ 	   - top of the task's userland stack
+ 	   - base address for mmap() requests that do not specify one
+ 	     (this includes all libraries)
+ 	   - base address of the main executable
+ 
+ 	  It is strongly recommended to say Y here as address space layout
+ 	  randomization has negligible impact on performance yet it provides
+ 	  a very effective protection.
+ 
+ 	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+ 	  this feature on a per file basis.
+ 
+ config MINISEC_RANDKSTACK
+ 	bool "Randomize kernel stack base"
+ 	default n
+ 	depends on X86_TSC && X86 && !XEN_PV
+ 	help
+ 	  By saying Y here the kernel will randomize every task's kernel
+ 	  stack on every system call.  This will not only force an attacker
+ 	  to guess it but also prevent him from making use of possible
+ 	  leaked information about it.
+ 
+ 	  Since the kernel stack is a rather scarce resource, randomization
+ 	  may cause unexpected stack overflows, therefore you should very
+ 	  carefully test your system.  Note that once enabled in the kernel
+ 	  configuration, this feature cannot be disabled on a per file basis.
+ 
+ config MINISEC_RANDUSTACK
+ 	bool
+ 
+ endmenu
+ 
+ menu "Filesystem Protections"
+ depends on MINISEC
+ 
+ config MINISEC_CHROOT
+ 	bool "Chroot jail restrictions"
+ 	default n
+ 	help
+ 	  If you say Y here, you will be able to choose several options that will
+ 	  make breaking out of a chrooted jail much more difficult.  If you
+ 	  encounter no software incompatibilities with the following options, it
+ 	  is recommended that you enable each one.
+ 
+ 	  Note that the chroot restrictions are not intended to apply to "chroots"
+ 	  to directories that are simple bind mounts of the global root filesystem.
+ 	  For several other reasons, a user shouldn't expect any significant
+ 	  security by performing such a chroot.
+ 
+ config MINISEC_CHROOT_MOUNT
+ 	bool "Deny mounts"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to
+ 	  mount or remount filesystems.  If the sysctl option is enabled, a
+ 	  sysctl option with name "chroot_deny_mount" is created.
+ 
+ config MINISEC_CHROOT_DOUBLE
+ 	bool "Deny double-chroots"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to chroot
+ 	  again outside the chroot.  This is a widely used method of breaking
+ 	  out of a chroot jail and should not be allowed.  If the sysctl
+ 	  option is enabled, a sysctl option with name
+ 	  "chroot_deny_chroot" is created.
+ 
+ config MINISEC_CHROOT_PIVOT
+ 	bool "Deny pivot_root in chroot"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to use
+ 	  a function called pivot_root() that was introduced in Linux 2.3.41.  It
+ 	  works similar to chroot in that it changes the root filesystem.  This
+ 	  function could be misused in a chrooted process to attempt to break out
+ 	  of the chroot, and therefore should not be allowed.  If the sysctl
+ 	  option is enabled, a sysctl option with name "chroot_deny_pivot" is
+ 	  created.
+ 
+ config MINISEC_CHROOT_CHDIR
+ 	bool "Enforce chdir(\"/\") on all chroots"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, the current working directory of all newly-chrooted
+ 	  applications will be set to the the root directory of the chroot.
+ 	  The man page on chroot(2) states:
+ 	  Note that this call does not change  the  current  working
+ 	  directory,  so  that `.' can be outside the tree rooted at
+ 	  `/'.  In particular, the  super-user  can  escape  from  a
+ 	  `chroot jail' by doing `mkdir foo; chroot foo; cd ..'.
+ 
+ 	  It is recommended that you say Y here, since it's not known to break
+ 	  any software.  If the sysctl option is enabled, a sysctl option with
+ 	  name "chroot_enforce_chdir" is created.
+ 
+ config MINISEC_CHROOT_CHMOD
+ 	bool "Deny (f)chmod s"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to chmod
+ 	  or fchmod files to make them have suid or sgid bits.  This protects
+ 	  against another published method of breaking a chroot.  If the sysctl
+ 	  option is enabled, a sysctl option with name "chroot_deny_chmod" is
+ 	  created.
+ 
+ config MINISEC_CHROOT_FCHDIR
+ 	bool "Deny fchdir and fhandle out of chroot"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, a well-known method of breaking chroots by fchdir'ing
+ 	  to a file descriptor of the chrooting process that points to a directory
+ 	  outside the filesystem will be stopped.  This option also prevents use of
+ 	  the recently-created syscall for opening files by a guessable "file handle"
+ 	  inside a chroot, as well as accessing relative paths outside of a
+ 	  directory passed in via file descriptor with openat and similar syscalls.
+ 	  If the sysctl option is enabled, a sysctl option with name "chroot_deny_fchdir"
+ 	  is created.
+ 
+ config MINISEC_CHROOT_MKNOD
+ 	bool "Deny mknod"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be allowed to
+ 	  mknod.  The problem with using mknod inside a chroot is that it
+ 	  would allow an attacker to create a device entry that is the same
+ 	  as one on the physical root of your system, which could range from
+ 	  anything from the console device to a device for your harddrive (which
+ 	  they could then use to wipe the drive or steal data).  It is recommended
+ 	  that you say Y here, unless you run into software incompatibilities.
+ 	  If the sysctl option is enabled, a sysctl option with name
+ 	  "chroot_deny_mknod" is created.
+ 
+ config MINISEC_CHROOT_SHMAT
+ 	bool "Deny shmat() out of chroot"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to attach
+ 	  to shared memory segments that were created outside of the chroot jail.
+ 	  It is recommended that you say Y here.  If the sysctl option is enabled,
+ 	  a sysctl option with name "chroot_deny_shmat" is created.
+ 
+ config MINISEC_CHROOT_UNIX
+ 	bool "Deny access to abstract AF_UNIX sockets out of chroot"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to
+ 	  connect to abstract (meaning not belonging to a filesystem) Unix
+ 	  domain sockets that were bound outside of a chroot.  It is recommended
+ 	  that you say Y here.  If the sysctl option is enabled, a sysctl option
+ 	  with name "chroot_deny_unix" is created.
+ 
+ config MINISEC_CHROOT_FINDTASK
+ 	bool "Protect outside processes"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to
+ 	  kill, send signals with fcntl, ptrace, capget, getpgid, setpgid,
+ 	  getsid, or view any process outside of the chroot.  If the sysctl
+ 	  option is enabled, a sysctl option with name "chroot_findtask" is
+ 	  created.
+ 
+ config MINISEC_CHROOT_NICE
+ 	bool "Restrict priority changes"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, processes inside a chroot will not be able to raise
+ 	  the priority of processes in the chroot, or alter the priority of
+ 	  processes outside the chroot.  This provides more security than simply
+ 	  removing CAP_SYS_NICE from the process' capability set.  If the
+ 	  sysctl option is enabled, a sysctl option with name "chroot_restrict_nice"
+ 	  is created.
+ 
+ config MINISEC_CHROOT_SYSCTL
+ 	bool "Deny sysctl writes"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, an attacker in a chroot will not be able to
+ 	  write to sysctl entries, either by sysctl(2) or through a /proc
+ 	  interface.  It is strongly recommended that you say Y here. If the
+ 	  sysctl option is enabled, a sysctl option with name
+ 	  "chroot_deny_sysctl" is created.
+ 
+ config MINISEC_CHROOT_RENAME
+ 	bool "Deny bad renames"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, an attacker in a chroot will not be able to
+ 	  abuse the ability to create double chroots to break out of the
+ 	  chroot by exploiting a race condition between a rename of a directory
+ 	  within a chroot against an open of a symlink with relative path
+ 	  components.  This feature will likewise prevent an accomplice outside
+ 	  a chroot from enabling a user inside the chroot to break out and make
+ 	  use of their credentials on the global filesystem.  Enabling this
+ 	  feature is essential to prevent root users from breaking out of a
+ 	  chroot. If the sysctl option is enabled, a sysctl option with name
+ 	  "chroot_deny_bad_rename" is created.
+ 
+ config MINISEC_CHROOT_CAPS
+ 	bool "Capability restrictions"
+ 	default n
+ 	depends on MINISEC_CHROOT
+ 	help
+ 	  If you say Y here, the capabilities on all processes within a
+ 	  chroot jail will be lowered to stop module insertion, raw i/o,
+ 	  system and net admin tasks, rebooting the system, modifying immutable
+ 	  files, modifying IPC owned by another, and changing the system time.
+ 	  This is left an option because it can break some apps.  Disable this
+ 	  if your chrooted apps are having problems performing those kinds of
+ 	  tasks.  If the sysctl option is enabled, a sysctl option with
+ 	  name "chroot_caps" is created.
+ 
+ config MINISEC_CHROOT_INITRD
+ 	bool "Exempt initrd tasks from restrictions"
+ 	default n
+ 	depends on MINISEC_CHROOT && BLK_DEV_INITRD
+ 	help
+ 	  If you say Y here, tasks started prior to init will be exempted from
+ 	  miniSEC's chroot restrictions.  This option is mainly meant to
+ 	  resolve Plymouth's performing privileged operations unnecessarily
+ 	  in a chroot.
+ 
+ config MINISEC_PROC
+ 	bool "Proc restrictions"
+ 	default n
+ 	help
+ 	  If you say Y here, the permissions of the /proc filesystem
+ 	  will be altered to enhance system security and privacy.  You MUST
+   	  choose either a user only restriction or a user and group restriction.
+ 	  Depending upon the option you choose, you can either restrict users to
+ 	  see only the processes they themselves run, or choose a group that can
+ 	  view all processes and files normally restricted to root if you choose
+ 	  the "restrict to user only" option.  NOTE: If you're running identd or
+ 	  ntpd as a non-root user, you will have to run it as the group you
+ 	  specify here.
+ 
+ config MINISEC_PROC_USER
+ 	bool "Restrict /proc to user only"
+ 	depends on MINISEC_PROC
+ 	help
+ 	  If you say Y here, non-root users will only be able to view their own
+ 	  processes, and restricts them from viewing network-related information,
+ 	  and viewing kernel symbol and module information.
+ 
+ config MINISEC_PROC_USERGROUP
+ 	bool "Allow special group"
+ 	default n
+ 	depends on MINISEC_PROC && !MINISEC_PROC_USER
+ 	help
+ 	  If you say Y here, you will be able to select a group that will be
+ 	  able to view all processes and network-related information.  If you've
+ 	  enabled MINISEC_HIDESYM, kernel and symbol information may still
+ 	  remain hidden.  This option is useful if you want to run identd as
+ 	  a non-root user.  The group you select may also be chosen at boot time
+ 	  via "grsec_proc_gid=" on the kernel commandline.
+ 
+ config MINISEC_PROC_GID
+ 	int "GID for special group"
+ 	depends on MINISEC_PROC_USERGROUP
+ 	default 1001
+ 
+ config MINISEC_PROC_ADD
+ 	bool "Additional restrictions"
+ 	default n
+ 	depends on MINISEC_PROC_USER || MINISEC_PROC_USERGROUP
+ 	help
+ 	  If you say Y here, additional restrictions will be placed on
+ 	  /proc that keep normal users from viewing device information and
+ 	  slabinfo information that could be useful for exploits.
+ 
+ config MINISEC_LINK
+ 	bool "Linking restrictions"
+ 	default n
+ 	help
+ 	  If you say Y here, /tmp race exploits will be prevented, since users
+ 	  will no longer be able to follow symlinks owned by other users in
+ 	  world-writable t directories (e.g. /tmp), unless the owner of the
+ 	  symlink is the owner of the directory. users will also not be
+ 	  able to hardlink to files they do not own.  If the sysctl option is
+ 	  enabled, a sysctl option with name "linking_restrictions" is created.
+ 
+ config MINISEC_SYMLINKOWN
+ 	bool "Kernel-enforced SymlinksIfOwnerMatch"
+ 	default n && MINISEC_CONFIG_SERVER
+ 	help
+ 	  Apache's SymlinksIfOwnerMatch option has an inherent race condition
+ 	  that prevents it from being used as a security feature.  As Apache
+ 	  verifies the symlink by performing a stat() against the target of
+ 	  the symlink before it is followed, an attacker can setup a symlink
+ 	  to point to a same-owned file, then replace the symlink with one
+ 	  that targets another user's file just after Apache "validates" the
+ 	  symlink -- a classic TOCTOU race.  If you say Y here, a complete,
+ 	  race-free replacement for Apache's "SymlinksIfOwnerMatch" option
+ 	  will be in place for the group you specify. If the sysctl option
+ 	  is enabled, a sysctl option with name "enforce_symlinksifowner" is
+ 	  created.
+ 
+ config MINISEC_SYMLINKOWN_GID
+ 	int "GID for users with kernel-enforced SymlinksIfOwnerMatch"
+ 	depends on MINISEC_SYMLINKOWN
+ 	default 1006
+ 	help
+ 	  Setting this GID determines what group kernel-enforced
+ 	  SymlinksIfOwnerMatch will be enabled for.  If the sysctl option
+ 	  is enabled, a sysctl option with name "symlinkown_gid" is created.
+ 
+ config MINISEC_FIFO
+ 	bool "FIFO restrictions"
+ 	default n
+ 	help
+ 	  If you say Y here, users will not be able to write to FIFOs they don't
+ 	  own in world-writable t directories (e.g. /tmp), unless the owner of
+ 	  the FIFO is the same owner of the directory it's held in.  If the sysctl
+ 	  option is enabled, a sysctl option with name "fifo_restrictions" is
+ 	  created.
+ 
+ config MINISEC_SYSFS_RESTRICT
+ 	bool "Sysfs/debugfs restriction"
+ 	default n
+ 	depends on SYSFS
+ 	help
+ 	  If you say Y here, sysfs (the pseudo-filesystem mounted at /sys) and
+ 	  any filesystem normally mounted under it (e.g. debugfs) will be
+ 	  mostly accessible only by root.  These filesystems generally provide access
+ 	  to hardware and debug information that isn't appropriate for unprivileged
+ 	  users of the system.  Sysfs and debugfs have also become a large source
+ 	  of new vulnerabilities, ranging from infoleaks to local compromise.
+ 	  There has been very little oversight with an eye toward security involved
+ 	  in adding new exporters of information to these filesystems, so their
+ 	  use is discouraged.
+ 	  For reasons of compatibility, a few directories have been whitelisted
+ 	  for access by non-root users:
+ 	  /sys/fs/selinux
+ 	  /sys/fs/fuse
+ 	  /sys/devices/system/cpu
+ 
+ endmenu
+ 
+ menu "Sysctl Support"
+ depends on MINISEC && SYSCTL
+ 
+ config MINISEC_SYSCTL
+ 	bool "Sysctl support"
+ 	default n
+ 	help
+ 	  If you say Y here, you will be able to change the options that
+ 	  miniSEC runs with at bootup, without having to recompile your
+ 	  kernel.  You can echo values to files in /proc/sys/kernel/grsecurity
+ 	  to enable (1) or disable (0) various features.  All the sysctl entries
+ 	  are mutable until the "grsec_lock" entry is set to a non-zero value.
+ 	  All features enabled in the kernel configuration are disabled at boot
+ 	  if you do not say Y to the "Turn on features by default" option.
+ 	  All options should be set at startup, and the grsec_lock entry should
+ 	  be set to a non-zero value after all the options are set.
+ 	  *THIS IS EXTREMELY IMPORTANT*
+ 
+ endmenu
+ 
+ config MINISEC_HARDEN_IPC
+ 	bool "Disallow access to overly-permissive IPC objects"
+ 	default n
+ 	depends on SYSVIPC
+ 	help
+ 	  If you say Y here, access to overly-permissive IPC objects (shared
+ 	  memory, message queues, and semaphores) will be denied for processes
+ 	  given the following criteria beyond normal permission checks:
+ 	  1) If the IPC object is world-accessible and the euid doesn't match
+ 	     that of the creator or current uid for the IPC object
+ 	  2) If the IPC object is group-accessible and the egid doesn't
+ 	     match that of the creator or current gid for the IPC object
+ 	  It's a common error to grant too much permission to these objects,
+ 	  with impact ranging from denial of service and information leaking to
+ 	  privilege escalation.  This feature was developed in response to
+ 	  research by Tim Brown:
+ 	  http://labs.portcullis.co.uk/whitepapers/memory-squatting-attacks-on-system-v-shared-memory/
+ 	  who found hundreds of such insecure usages.  Processes with
+ 	  CAP_IPC_OWNER are still permitted to access these IPC objects.
+ 	  If the sysctl option is enabled, a sysctl option with name
+ 	  "harden_ipc" is created.
+ 
+ config MINISEC_HARDEN_TTY
+ 	bool "Disallow unprivileged use of command injection"
+ 	default n
+ 	depends on !SECURITY_TIOCSTI_RESTRICT
+ 	help
+ 	  If you say Y here, the ability to use the TIOCSTI ioctl for
+ 	  terminal command injection will be denied for unprivileged users.
+ 	  There are very few legitimate uses for this functionality and it
+ 	  has made vulnerabilities in several 'su'-like programs possible in
+ 	  the past.  Even without these vulnerabilities, it provides an
+ 	  attacker with an easy mechanism to move laterally among other
+ 	  processes within the same user's compromised session.
+ 	  By default, Linux allows unprivileged use of command injection as
+ 	  long as the injection is being performed into the same tty session.
+ 	  This feature makes that case the same as attempting to inject into
+ 	  another session, making any TIOCSTI use require CAP_SYS_ADMIN.
+ 	  If the sysctl option is enabled, a sysctl option with name
+ 	  "harden_tty" is created.
+ 
+ endmenu
+ 
  config SECURITY_DMESG_RESTRICT
  	bool "Restrict unprivileged access to the kernel syslog"
  	default y
***************
*** 353,356 ****
  source "security/Kconfig.hardening"
  
  endmenu
- 
--- 1007,1009 ----
diff -rcNP og/security/Makefile patched/security/Makefile
*** og/security/Makefile	2021-03-11 15:06:51.000000000 +0200
--- patched/security/Makefile	2021-03-13 19:27:26.000000000 +0200
***************
*** 30,35 ****
--- 30,36 ----
  obj-$(CONFIG_SECURITY_SAFESETID)       += safesetid/
  obj-$(CONFIG_SECURITY_LOCKDOWN_LSM)	+= lockdown/
  obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
+ obj-$(CONFIG_MINISEC)                   += minisec/
  
  # Object integrity file lists
  subdir-$(CONFIG_INTEGRITY)		+= integrity
diff -rcNP og/security/minisec/Makefile patched/security/minisec/Makefile
*** og/security/minisec/Makefile	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/Makefile	2021-03-13 19:28:13.000000000 +0200
***************
*** 0 ****
--- 1,4 ----
+ # SPDX-License-Identifier: GPL-2.0
+ # Makefile for miniSEC
+ #
+ obj-$(CONFIG_MINISEC) += chroot.o init.o ipc.o proc.o sysctl.o tty.o
diff -rcNP og/security/minisec/chroot.c patched/security/minisec/chroot.c
*** og/security/minisec/chroot.c	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/chroot.c	2021-03-13 19:29:42.000000000 +0200
***************
*** 0 ****
--- 1,485 ----
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <linux/sched.h>
+ #include <linux/file.h>
+ #include <linux/fs.h>
+ #include <linux/mount.h>
+ #include <linux/types.h>
+ #include <linux/namei.h>
+ #include <linux/fs_struct.h>
+ #include <linux/nsproxy.h>
+ #include <linux/minisec.h>
+ #include "../fs/mount.h"
+ 
+ #ifdef CONFIG_MINISEC_CHROOT_INITRD
+ int gr_init_ran;
+ #endif
+ 
+ void gr_inc_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	struct dentry *tmpd = dentry;
+ 
+ 	read_seqlock_excl(&mount_lock);
+ 	write_seqlock(&rename_lock);
+ 
+ 	while (tmpd != mnt->mnt_root) {
+ 		atomic_inc(&tmpd->chroot_refcnt);
+ 		tmpd = tmpd->d_parent;
+ 	}
+ 	atomic_inc(&tmpd->chroot_refcnt);
+ 
+ 	write_sequnlock(&rename_lock);
+ 	read_sequnlock_excl(&mount_lock);
+ #endif
+ }
+ 
+ void gr_dec_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	struct dentry *tmpd = dentry;
+ 
+ 	read_seqlock_excl(&mount_lock);
+ 	write_seqlock(&rename_lock);
+ 
+ 	while (tmpd != mnt->mnt_root) {
+ 		atomic_dec(&tmpd->chroot_refcnt);
+ 		tmpd = tmpd->d_parent;
+ 	}
+ 	atomic_dec(&tmpd->chroot_refcnt);
+ 
+ 	write_sequnlock(&rename_lock);
+ 	read_sequnlock_excl(&mount_lock);
+ #endif
+ }
+ 
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ static struct dentry *get_closest_chroot(struct dentry *dentry)
+ {
+ 	write_seqlock(&rename_lock);
+ 	do {
+ 		if (atomic_read(&dentry->chroot_refcnt)) {
+ 			write_sequnlock(&rename_lock);
+ 			return dentry;
+ 		}
+ 		dentry = dentry->d_parent;
+ 	} while (!IS_ROOT(dentry));
+ 	write_sequnlock(&rename_lock);
+ 	return NULL;
+ }
+ #endif
+ 
+ int gr_bad_chroot_rename(struct dentry *olddentry, struct vfsmount *oldmnt,
+ 			 struct dentry *newdentry, struct vfsmount *newmnt)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	struct dentry *chroot;
+ 
+ 	if (unlikely(!grsec_enable_chroot_rename))
+ 		return 0;
+ 
+ 	if (likely(!proc_is_chrooted(current) && gr_is_global_root(current_uid())))
+ 		return 0;
+ 
+ 	chroot = get_closest_chroot(olddentry);
+ 
+ 	if (chroot == NULL)
+ 		return 0;
+ 
+ 	if (is_subdir(newdentry, chroot))
+ 		return 0;
+ 
+ 	return 1;
+ #else
+ 	return 0;
+ #endif
+ }
+ 
+ void gr_set_chroot_entries(struct task_struct *task, const struct path *path)
+ {
+ #ifdef CONFIG_MINISEC
+ 	if (task_pid_nr(task) > 1 && path->dentry != init_task.fs->root.dentry &&
+ 	    		     path->dentry != task->nsproxy->mnt_ns->root->mnt.mnt_root
+ #ifdef CONFIG_MINISEC_CHROOT_INITRD
+ 			     && gr_init_ran
+ #endif
+ 	   )
+ 		task->gr_is_chrooted = 1;
+ 	else {
+ #ifdef CONFIG_MINISEC_CHROOT_INITRD
+ 		if (task_pid_nr(task) == 1 && !gr_init_ran)
+ 			gr_init_ran = 1;
+ #endif
+ 		task->gr_is_chrooted = 0;
+ 	}
+ 
+ 	task->gr_chroot_dentry = path->dentry;
+ #endif
+ 	return;
+ }
+ 
+ void gr_clear_chroot_entries(struct task_struct *task)
+ {
+ #ifdef CONFIG_MINISEC
+ 	task->gr_is_chrooted = 0;
+ 	task->gr_chroot_dentry = NULL;
+ #endif
+ 	return;
+ }
+ 
+ int
+ gr_handle_chroot_unix(const pid_t pid)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_UNIX
+ 	struct task_struct *p;
+ 
+ 	if (unlikely(!grsec_enable_chroot_unix))
+ 		return 1;
+ 
+ 	if (likely(!proc_is_chrooted(current)))
+ 		return 1;
+ 
+ 	rcu_read_lock();
+ 	read_lock(&tasklist_lock);
+ 	p = find_task_by_vpid_unrestricted(pid);
+ 	if (unlikely(p && !have_same_root(current, p))) {
+ 		read_unlock(&tasklist_lock);
+ 		rcu_read_unlock();
+ 		return 0;
+ 	}
+ 	read_unlock(&tasklist_lock);
+ 	rcu_read_unlock();
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_handle_chroot_nice(void)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_NICE
+ 	if (grsec_enable_chroot_nice && proc_is_chrooted(current)) {
+ 		return -EPERM;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_handle_chroot_setpriority(struct task_struct *p, const int niceval)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_NICE
+ 	if (grsec_enable_chroot_nice && (niceval < task_nice(p))
+ 			&& proc_is_chrooted(current)) {
+ 		return -EACCES;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_handle_chroot_fowner(struct pid *pid, enum pid_type type)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_FINDTASK
+ 	struct task_struct *p;
+ 	int ret = 0;
+ 	if (!grsec_enable_chroot_findtask || !proc_is_chrooted(current) || !pid)
+ 		return ret;
+ 
+ 	read_lock(&tasklist_lock);
+ 	do_each_pid_task(pid, type, p) {
+ 		if (!have_same_root(current, p)) {
+ 			ret = 1;
+ 			goto out;
+ 		}
+ 	} while_each_pid_task(pid, type, p);
+ out:
+ 	read_unlock(&tasklist_lock);
+ 	return ret;
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_pid_is_chrooted(struct task_struct *p)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_FINDTASK
+ 	if (!grsec_enable_chroot_findtask || !proc_is_chrooted(current) || p == NULL)
+ 		return 0;
+ 
+ 	if ((p->exit_state & (EXIT_ZOMBIE | EXIT_DEAD)) ||
+ 	    !have_same_root(current, p)) {
+ 		return 1;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ EXPORT_SYMBOL_GPL(gr_pid_is_chrooted);
+ 
+ #if defined(CONFIG_MINISEC_CHROOT_DOUBLE) || defined(CONFIG_MINISEC_CHROOT_FCHDIR)
+ int gr_is_outside_chroot(const struct dentry *u_dentry, const struct vfsmount *u_mnt)
+ {
+ 	struct path path, currentroot;
+ 	int ret = 0;
+ 
+ 	path.dentry = (struct dentry *)u_dentry;
+ 	path.mnt = (struct vfsmount *)u_mnt;
+ 	get_fs_root(current->fs, &currentroot);
+ 	if (path_is_under(&path, &currentroot))
+ 		ret = 1;
+ 	path_put(&currentroot);
+ 
+ 	return ret;
+ }
+ #endif
+ 
+ int
+ gr_chroot_fchdir(struct dentry *u_dentry, struct vfsmount *u_mnt)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_FCHDIR
+ 	if (!grsec_enable_chroot_fchdir)
+ 		return 1;
+ 
+ 	if (!proc_is_chrooted(current))
+ 		return 1;
+ 	else if (!gr_is_outside_chroot(u_dentry, u_mnt)) {
+ 		return 0;
+ 	}
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_chroot_pathat(int dfd, struct dentry *u_dentry, struct vfsmount *u_mnt, unsigned flags)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_FCHDIR
+ 	struct fd f;
+ 	struct path fd_path;
+ 	struct path file_path;
+ 
+ 	if (!grsec_enable_chroot_fchdir)
+ 		return 0;
+ 
+ 	if (!proc_is_chrooted(current) || dfd == -1 || dfd == AT_FDCWD)
+ 		return 0;
+ 
+ 	if (flags & LOOKUP_RCU)
+ 		return -ECHILD;
+ 
+ 	f = fdget_raw(dfd);
+ 	if (!f.file)
+ 		return 0;
+ 
+ 	fd_path = f.file->f_path;
+ 	path_get(&fd_path);
+ 	fdput(f);
+ 
+ 	file_path.dentry = u_dentry;
+ 	file_path.mnt = u_mnt;
+ 
+ 	if (!gr_is_outside_chroot(u_dentry, u_mnt) && !path_is_under(&file_path, &fd_path)) {
+ 		path_put(&fd_path);
+ 		return -ENOENT;
+ 	}
+ 	path_put(&fd_path);
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_chroot_fhandle(void)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_FCHDIR
+ 	if (!grsec_enable_chroot_fchdir)
+ 		return 1;
+ 
+ 	if (!proc_is_chrooted(current))
+ 		return 1;
+ 	else {
+ 		return 0;
+ 	}
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_chroot_shmat(const pid_t shm_cprid, const pid_t shm_lapid,
+ 		const u64 shm_createtime)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_SHMAT
+ 	struct task_struct *p;
+ 
+ 	if (unlikely(!grsec_enable_chroot_shmat))
+ 		return 1;
+ 
+ 	if (likely(!proc_is_chrooted(current)))
+ 		return 1;
+ 
+ 	rcu_read_lock();
+ 	read_lock(&tasklist_lock);
+ 
+ 	if ((p = find_task_by_vpid_unrestricted(shm_cprid))) {
+ 		if (time_before_eq64(p->start_time, shm_createtime)) {
+ 			if (have_same_root(current, p)) {
+ 				goto allow;
+ 			} else {
+ 				read_unlock(&tasklist_lock);
+ 				rcu_read_unlock();
+ 				return 0;
+ 			}
+ 		}
+ 		/* creator exited, pid reuse, fall through to next check */
+ 	}
+ 	if ((p = find_task_by_vpid_unrestricted(shm_lapid))) {
+ 		if (unlikely(!have_same_root(current, p))) {
+ 			read_unlock(&tasklist_lock);
+ 			rcu_read_unlock();
+ 			return 0;
+ 		}
+ 	}
+ 
+ allow:
+ 	read_unlock(&tasklist_lock);
+ 	rcu_read_unlock();
+ #endif
+ 	return 1;
+ }
+ 
+ void
+ gr_log_chroot_exec(const struct dentry *dentry, const struct vfsmount *mnt)
+ {
+ 	return;
+ }
+ 
+ int
+ gr_handle_chroot_mknod(const struct dentry *dentry,
+ 		       const struct vfsmount *mnt, const int mode)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_MKNOD
+ 	if (grsec_enable_chroot_mknod && !S_ISFIFO(mode) && !S_ISREG(mode) &&
+ 	    proc_is_chrooted(current)) {
+ 		return -EPERM;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_handle_chroot_mount(const struct dentry *dentry,
+ 		       const struct vfsmount *mnt, const char *dev_name)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_MOUNT
+ 	if (grsec_enable_chroot_mount && proc_is_chrooted(current)) {
+ 		return -EPERM;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_handle_chroot_pivot(void)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_PIVOT
+ 	if (grsec_enable_chroot_pivot && proc_is_chrooted(current)) {
+ 		return -EPERM;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ int
+ gr_handle_chroot_chroot(const struct dentry *dentry, const struct vfsmount *mnt)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_DOUBLE
+ 	if (grsec_enable_chroot_double && proc_is_chrooted(current) &&
+ 	    !gr_is_outside_chroot(dentry, mnt)) {
+ 		return -EPERM;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ extern const char *captab_log[];
+ extern int captab_log_entries;
+ 
+ int
+ gr_task_chroot_is_capable(const struct task_struct *task, const struct cred *cred, const int cap)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_CAPS
+ 	if (grsec_enable_chroot_caps && proc_is_chrooted(task)) {
+ 		kernel_cap_t chroot_caps = GR_CHROOT_CAPS;
+ 		if (cap_raised(chroot_caps, cap)) {
+ 			return 0;
+ 		}
+ 	}
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_chroot_is_capable(const int cap)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_CAPS
+ 	return gr_task_chroot_is_capable(current, current_cred(), cap);
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_task_chroot_is_capable_nolog(const struct task_struct *task, const int cap)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_CAPS
+ 	if (grsec_enable_chroot_caps && proc_is_chrooted(task)) {
+ 		kernel_cap_t chroot_caps = GR_CHROOT_CAPS;
+ 		if (cap_raised(chroot_caps, cap)) {
+ 			return 0;
+ 		}
+ 	}
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_chroot_is_capable_nolog(const int cap)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_CAPS
+ 	return gr_task_chroot_is_capable_nolog(current, cap);
+ #endif
+ 	return 1;
+ }
+ 
+ int
+ gr_handle_chroot_sysctl(const int op)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_SYSCTL
+ 	if (grsec_enable_chroot_sysctl && (op & MAY_WRITE) &&
+ 	    proc_is_chrooted(current))
+ 		return -EACCES;
+ #endif
+ 	return 0;
+ }
+ 
+ void
+ gr_handle_chroot_chdir(const struct path *path)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_CHDIR
+ 	if (grsec_enable_chroot_chdir)
+ 		set_fs_pwd(current->fs, path);
+ #endif
+ 	return;
+ }
+ 
+ int
+ gr_handle_chroot_chmod(const struct dentry *dentry,
+ 		       const struct vfsmount *mnt, const int mode)
+ {
+ #ifdef CONFIG_MINISEC_CHROOT_CHMOD
+ 	/* allow chmod +s on directories, but not files */
+ 	if (grsec_enable_chroot_chmod && !d_is_dir(dentry) &&
+ 	    ((mode & S_ISUID) || ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))) &&
+ 	    proc_is_chrooted(current)) {
+ 		return -EPERM;
+ 	}
+ #endif
+ 	return 0;
+ }
diff -rcNP og/security/minisec/init.c patched/security/minisec/init.c
*** og/security/minisec/init.c	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/init.c	2021-03-13 19:30:05.000000000 +0200
***************
*** 0 ****
--- 1,81 ----
+ #include <linux/kernel.h>
+ 
+ int grsec_enable_chroot_findtask;
+ int grsec_enable_chroot_shmat;
+ int grsec_enable_chroot_mount;
+ int grsec_enable_chroot_double;
+ int grsec_enable_chroot_pivot;
+ int grsec_enable_chroot_chdir;
+ int grsec_enable_chroot_chmod;
+ int grsec_enable_chroot_mknod;
+ int grsec_enable_chroot_fchdir;
+ int grsec_enable_chroot_nice;
+ int grsec_enable_chroot_execlog;
+ int grsec_enable_chroot_caps;
+ int grsec_enable_chroot_rename;
+ int grsec_enable_chroot_sysctl;
+ int grsec_enable_chroot_unix;
+ int grsec_enable_harden_ipc;
+ int grsec_enable_harden_tty;
+ int grsec_lock;
+ 
+ void __init
+ minisec_init(void)
+ {
+ #ifdef CONFIG_MINISEC_HARDEN_IPC
+ 	grsec_enable_harden_ipc = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_HARDEN_TTY
+ 	grsec_enable_harden_tty = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_FINDTASK
+ 	grsec_enable_chroot_findtask = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_UNIX
+ 	grsec_enable_chroot_unix = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_MOUNT
+ 	grsec_enable_chroot_mount = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_FCHDIR
+ 	grsec_enable_chroot_fchdir = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_SHMAT
+ 	grsec_enable_chroot_shmat = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_AUDIT_PTRACE
+ 	grsec_enable_audit_ptrace = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_DOUBLE
+ 	grsec_enable_chroot_double = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_PIVOT
+ 	grsec_enable_chroot_pivot = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_CHDIR
+ 	grsec_enable_chroot_chdir = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_CHMOD
+ 	grsec_enable_chroot_chmod = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_MKNOD
+ 	grsec_enable_chroot_mknod = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_NICE
+ 	grsec_enable_chroot_nice = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_EXECLOG
+ 	grsec_enable_chroot_execlog = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_CAPS
+ 	grsec_enable_chroot_caps = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	grsec_enable_chroot_rename = 1;
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_SYSCTL
+ 	grsec_enable_chroot_sysctl = 1;
+ #endif
+ 
+ 	return;
+ }
diff -rcNP og/security/minisec/ipc.c patched/security/minisec/ipc.c
*** og/security/minisec/ipc.c	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/ipc.c	2021-03-13 19:30:31.000000000 +0200
***************
*** 0 ****
--- 1,46 ----
+ #include <linux/kernel.h>
+ #include <linux/mm.h>
+ #include <linux/sched.h>
+ #include <linux/file.h>
+ #include <linux/ipc.h>
+ #include <linux/ipc_namespace.h>
+ #include <linux/minisec.h>
+ 
+ int
+ gr_ipc_permitted(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, int requested_mode, int granted_mode)
+ {
+ #ifdef CONFIG_MINISEC_HARDEN_IPC
+ 	int write;
+ 	int orig_granted_mode;
+ 	kuid_t euid;
+ 	kgid_t egid;
+ 
+ 	if (!grsec_enable_harden_ipc)
+ 		return 1;
+ 
+ 	euid = current_euid();
+ 	egid = current_egid();
+ 
+ 	write = requested_mode & 00002;
+ 	orig_granted_mode = ipcp->mode;
+ 
+ 	if (uid_eq(euid, ipcp->cuid) || uid_eq(euid, ipcp->uid))
+ 		orig_granted_mode >>= 6;
+ 	else {
+ 		/* if likely wrong permissions, lock to user */
+ 		if (orig_granted_mode & 0007)
+ 			orig_granted_mode = 0;
+ 		/* otherwise do a egid-only check */
+ 		else if (gid_eq(egid, ipcp->cgid) || gid_eq(egid, ipcp->gid))
+ 			orig_granted_mode >>= 3;
+ 		/* otherwise, no access */
+ 		else
+ 			orig_granted_mode = 0;
+ 	}
+ 	if (!(requested_mode & ~granted_mode & 0007) && (requested_mode & ~orig_granted_mode & 0007) &&
+ 	    !ns_capable_noaudit(ns->user_ns, CAP_IPC_OWNER)) {
+ 		return 0;
+ 	}
+ #endif
+ 	return 1;
+ }
diff -rcNP og/security/minisec/proc.c patched/security/minisec/proc.c
*** og/security/minisec/proc.c	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/proc.c	2021-03-13 19:30:52.000000000 +0200
***************
*** 0 ****
--- 1,19 ----
+ #include <linux/kernel.h>
+ #include <linux/sched.h>
+ #include <linux/minisec.h>
+ 
+ int gr_proc_is_restricted(void)
+ {
+ #if defined(CONFIG_MINISEC_PROC_USER) || defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	const struct cred *cred = current_cred();
+ #endif
+ 
+ #ifdef CONFIG_MINISEC_PROC_USER
+ 	if (!uid_eq(cred->fsuid, GLOBAL_ROOT_UID))
+ 		return -EACCES;
+ #elif defined(CONFIG_MINISEC_PROC_USERGROUP)
+ 	if (!uid_eq(cred->fsuid, GLOBAL_ROOT_UID) && !in_group_p(grsec_proc_gid))
+ 		return -EACCES;
+ #endif
+ 	return 0;
+ }
diff -rcNP og/security/minisec/sysctl.c patched/security/minisec/sysctl.c
*** og/security/minisec/sysctl.c	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/sysctl.c	2021-03-13 19:31:17.000000000 +0200
***************
*** 0 ****
--- 1,183 ----
+ #include <linux/kernel.h>
+ #include <linux/sched.h>
+ #include <linux/sysctl.h>
+ #include <linux/minisec.h>
+ 
+ int
+ gr_handle_sysctl_mod(const char *dirname, const char *name, const int op)
+ {
+ #ifdef CONFIG_MINISEC_SYSCTL
+ 	if (dirname == NULL || name == NULL)
+ 		return 0;
+ 	if (!strcmp(dirname, "grsecurity") && grsec_lock && (op & MAY_WRITE)) {
+ 		return -EACCES;
+ 	}
+ #endif
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_MINISEC_SYSCTL
+ struct ctl_table grsecurity_table[] = {
+ #ifdef CONFIG_MINISEC_HARDEN_IPC
+ 	{
+ 		.procname	= "harden_ipc",
+ 		.data		= &grsec_enable_harden_ipc,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_HARDEN_TTY
+ 	{
+ 		.procname	= "harden_tty",
+ 		.data		= &grsec_enable_harden_tty,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_SHMAT
+ 	{
+ 		.procname	= "chroot_deny_shmat",
+ 		.data		= &grsec_enable_chroot_shmat,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_UNIX
+ 	{
+ 		.procname	= "chroot_deny_unix",
+ 		.data		= &grsec_enable_chroot_unix,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_MOUNT
+ 	{
+ 		.procname	= "chroot_deny_mount",
+ 		.data		= &grsec_enable_chroot_mount,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_FCHDIR
+ 	{
+ 		.procname	= "chroot_deny_fchdir",
+ 		.data		= &grsec_enable_chroot_fchdir,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_DOUBLE
+ 	{
+ 		.procname	= "chroot_deny_chroot",
+ 		.data		= &grsec_enable_chroot_double,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_PIVOT
+ 	{
+ 		.procname	= "chroot_deny_pivot",
+ 		.data		= &grsec_enable_chroot_pivot,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_CHDIR
+ 	{
+ 		.procname	= "chroot_enforce_chdir",
+ 		.data		= &grsec_enable_chroot_chdir,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_CHMOD
+ 	{
+ 		.procname	= "chroot_deny_chmod",
+ 		.data		= &grsec_enable_chroot_chmod,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_MKNOD
+ 	{
+ 		.procname	= "chroot_deny_mknod",
+ 		.data		= &grsec_enable_chroot_mknod,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_NICE
+ 	{
+ 		.procname	= "chroot_restrict_nice",
+ 		.data		= &grsec_enable_chroot_nice,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_EXECLOG
+ 	{
+ 		.procname	= "chroot_execlog",
+ 		.data		= &grsec_enable_chroot_execlog,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_CAPS
+ 	{
+ 		.procname	= "chroot_caps",
+ 		.data		= &grsec_enable_chroot_caps,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_RENAME
+ 	{
+ 		.procname	= "chroot_deny_bad_rename",
+ 		.data		= &grsec_enable_chroot_rename,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_SYSCTL
+ 	{
+ 		.procname	= "chroot_deny_sysctl",
+ 		.data		= &grsec_enable_chroot_sysctl,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ #ifdef CONFIG_MINISEC_CHROOT_FINDTASK
+ 	{
+ 		.procname	= "chroot_findtask",
+ 		.data		= &grsec_enable_chroot_findtask,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ #endif
+ 	{
+ 		.procname	= "grsec_lock",
+ 		.data		= &grsec_lock,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0600,
+ 		.proc_handler	= &proc_dointvec_secure,
+ 	},
+ 	{ }
+ };
+ #endif
diff -rcNP og/security/minisec/tty.c patched/security/minisec/tty.c
*** og/security/minisec/tty.c	1970-01-01 03:00:00.000000000 +0300
--- patched/security/minisec/tty.c	2021-03-13 19:31:41.000000000 +0200
***************
*** 0 ****
--- 1,16 ----
+ #include <linux/kernel.h>
+ #include <linux/sched.h>
+ #include <linux/minisec.h>
+ #include <linux/capability.h>
+ #include <linux/tty.h>
+ 
+ int gr_handle_tiocsti(struct tty_struct *tty)
+ {
+ #ifdef CONFIG_MINISEC_HARDEN_TTY
+ 	if (grsec_enable_harden_tty && (current->signal->tty == tty) &&
+ 	    !capable(CAP_SYS_ADMIN)) {
+ 		return 1;
+ 	}
+ #endif
+ 	return 0;
+ }
diff -rcNP og/virt/kvm/kvm_main.c patched/virt/kvm/kvm_main.c
*** og/virt/kvm/kvm_main.c	2021-03-11 15:06:51.000000000 +0200
--- patched/virt/kvm/kvm_main.c	2021-03-13 19:32:29.000000000 +0200
***************
*** 639,644 ****
--- 639,648 ----
  	struct kvm_stat_data *stat_data;
  	struct kvm_stats_debugfs_item *p;
  
+ #ifdef CONFIG_MINISEC_SYSFS_RESTRICT
+ 	return 0;
+ #endif
+ 
  	if (!debugfs_initialized())
  		return 0;
  
***************
*** 1642,1648 ****
  	 * Whoever called remap_pfn_range is also going to call e.g.
  	 * unmap_mapping_range before the underlying pages are freed,
  	 * causing a call to our MMU notifier.
! 	 */ 
  	kvm_get_pfn(pfn);
  
  out:
--- 1646,1652 ----
  	 * Whoever called remap_pfn_range is also going to call e.g.
  	 * unmap_mapping_range before the underlying pages are freed,
  	 * causing a call to our MMU notifier.
! 	 */
  	kvm_get_pfn(pfn);
  
  out:
